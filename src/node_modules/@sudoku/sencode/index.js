import { IS_ADDITIVE,GRID_COORDS, GRID_LENGTH, SENCODE_REGEX, SENCODE_SEPARATOR as SEPARATOR, SENCODE_SEPARATOR_REVERSE as SEPARATOR_REVERSE } from '@sudoku/constants';
import Base62 from './base62';

/**
 * @param {number[]} flatGrid
 * @returns {boolean}
 */
function shouldReverse(flatGrid) {
	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		if (flatGrid[(GRID_LENGTH - 1) - cell] !== 0) {
			return false;
		} else if (flatGrid[cell] !== 0) {
			return true;
		}
	}

	return false;
}


/**
 * @param {number[][]} sudoku
 * @returns {string}
 */
export function encodeSudoku(sudoku) {
	/** @type number[] */
	const flatGrid = sudoku.flat();

	const reversed = shouldReverse(flatGrid);
	if (reversed) {
		// Reverse sudoku array
		flatGrid.reverse();
	}

	let structure = '';
	let numbers = '';

	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		structure += (flatGrid[cell] === 0 ? '0' : '1');

		if (flatGrid[cell] > 0) {
			numbers += flatGrid[cell] - 1; // Subtract 1 so the number gets smaller
		}
	}

	return Base62.encode(BigInt('0b' + structure)) +
	       (reversed ? SEPARATOR_REVERSE : SEPARATOR) +
	       Base62.encode(BigInt(numbers));
}

/**常鹏：测试从外部导入url解析为数独数组
 * @param {string} input //https://www.sudokuwiki.org/sudoku.htm?bd=300052000250300010004607523093200805570000030408035060005408300030506084840023056
 * @returns {number[][]}
 */
export function testSudoku(input) {
	IS_ADDITIVE.set(true)
	return decodeSencode(input);
}

/**
 * @param {string} sencode
 * @returns {number[][]}
 */
export function decodeSencode(sencode) {
	let grid = [
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	];

	let flag=false;
	IS_ADDITIVE.subscribe(value => {
		flag = value;
	  });
	if(flag){
		//常鹏：自定义解析url数独串：100004000...0009格式
		sencode = extractSencode(sencode);
		if (sencode === null) {throw new Error('Invalid Sencode');}
		for(let row=0;row<9;row++){
			for(let col=0;col<9;col++){
				let val = sencode[row*9+col];
				if(val>='1'&& val<='9'){
					grid[row][col]=parseInt(val, 10);//转换成数字
				}
			}
		}
		return grid;
	}

	//原始的默认解析数独串
	const reversed = sencode.indexOf(SEPARATOR_REVERSE) !== -1;

	const [encodedStructure, encodedNumbers] = sencode.split(reversed ? SEPARATOR_REVERSE : SEPARATOR);

	// Base62编码处理逻辑
	const structure = Base62.decode(encodedStructure)
	                        .toString(2)
	                        .padStart(GRID_LENGTH, '0');

	let numberCount = 0;
	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		if (structure[cell] === '1') {
			numberCount++;
		}
	}

	let numbers = Base62.decode(encodedNumbers)
	                    .toString()
	                    .padStart(numberCount, '0')
	                    .split('');

	for (let cell = 0; cell < GRID_LENGTH; cell++) {
		if (structure[cell] === '1') {
			const [row, col] = GRID_COORDS[cell];
			grid[row][col] = numbers.shift() * 1 + 1;
		}
	}

	if (reversed) {
		// Reverse Grid
		grid = grid.reverse().map(row => row.reverse());
	}

	return grid;
}



 * 常鹏：正则表达式处理输入的sudoku url
 * @param {string} input 输入的sudoku字符串或url
 * @returns 处理的结果，正常返回长度为81的字符串，否则返回 null
 */
export function extractSencode(input) {
    // 支持两种正则表达式： 1. /sudoku?bd=100004000...0009  2. 100004000...0009
    const urlRegex = /[?&]bd=([0-9]{81})/; // URL 中的 bd 参数
    const plainRegex = /^[0-9]{81}$/;             // 直接输入 81 个数字

    // 检查是否是 URL 格式
    const urlMatch = input.match(urlRegex);
    if (urlMatch) {
        return ''+urlMatch[1]; // 提取 bd 参数的值
    }

    // 检查是否是直接输入的 81 个数字
    if (plainRegex.test(input)) {
        return input;
    }

    // 如果都不匹配，返回 null
    return null;
}


// 常鹏：增加额外的验证逻辑
export function validateSencode(sencode) {
	const urlRegex = /[?&]bd=([0-9]{81})/; // URL 中的 bd 参数
    const plainRegex = /^[0-9]{81}$/;             // 直接输入 81 个数字
										// 原始 6D2oa6igMGhdyj-8U8xwkRzeM9NqAHWEThLtiB
	let flag = true;
	let isAdditive = false;

	if(SENCODE_REGEX.test(sencode)){
		isAdditive = false;
	}else if(sencode.match(urlRegex)||sencode.match(plainRegex)){
		isAdditive = true;
	}else{
		flag = false;
	}
	// 常鹏：更新IS_ADDITIVE用于判断是否为外部sudoku wiki的url导入
	IS_ADDITIVE.set(isAdditive);
	return sencode && sencode.trim().length !== 0 && flag;
}