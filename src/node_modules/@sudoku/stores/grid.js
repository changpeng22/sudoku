import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import { derived, writable } from 'svelte/store';
import { hints } from './hints';
// 钿哥导入模块
import { candidates } from './candidates';

// 钿哥添加历史记录全局变量
export const history = writable([]);
export const historyIndex = writable(-1);

function createGrid() {
	const grid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	return {
		subscribe: grid.subscribe,

		generate(difficulty) {
			grid.set(generateSudoku(difficulty));
		},

		decodeSencode(sencode) {
			grid.set(decodeSencode(sencode));
		},

		get(gridStore, x, y) {
			return gridStore[y][x];
		},

		getSencode(gridStore) {
			return encodeSudoku(gridStore);
		},
	};
}

export const grid = createGrid();


function createUserGrid() {
	const userGrid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	grid.subscribe($grid => {
		let newGrid = [];

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			newGrid[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				newGrid[y][x] = $grid[y][x];
			}
		}

		userGrid.set(newGrid);
	});

	// 常鹏：保存的网格
	let savedGridStack = []; 
	return {
		subscribe: userGrid.subscribe,

		set: (pos, value) => {
			userGrid.update($userGrid => {
				// 钿哥添加历史记录
				history.update($history => {
					historyIndex.update($historyIndex => {
						$history = $history.slice(0, $historyIndex + 1);
						$history.push({ pos: pos, value: $userGrid[pos.y][pos.x] });
						$historyIndex++;
						return $historyIndex;
					})
					return $history;
				});
				

				$userGrid[pos.y][pos.x] = value;
				return $userGrid;
			});
		},


		// 钿哥改名
		applyHintWithPos: (pos) => {
			hints.useHint();
			userGrid.update($userGrid => {
				const solvedSudoku = solveSudoku($userGrid);
				$userGrid[pos.y][pos.x] = solvedSudoku[pos.y][pos.x];
				return $userGrid;
			});
		},

		// 钿哥修改为按照候选值的数量来应用提示
		applyHint: (maxCandidateCount = 3) => {
			console.log('applyHint');
			hints.useHint();
			userGrid.update($userGrid => {
				const solvedSudoku = solveSudoku($userGrid);
				/*
				const solvedSudoku = {
					1: [
						[0, 0, [5]],
						[1, 2, [3]]
					],
					2: [
						[0, 1, [1, 2]],
						[2, 2, [4, 6]]
					],
					3: [
						[3, 3, [7, 8, 9]]
					]
				};
				*/
				// Iterate over each solution
				for (const [candidateCount, solutions] of Object.entries(solvedSudoku)) {
					if (candidateCount <= maxCandidateCount) {
						for (const solution of solutions) {
							const [row, col, candidate_nums] = solution;
							console.log(row, col, candidate_nums);
							candidate_nums.forEach(candidate => {
								candidates.add({ x: col, y: row }, candidate);
							});
						}
					}
				}
				return $userGrid;
			});
		},

        // 保存当前网格到栈
        saveGrid: () => {
            userGrid.subscribe($userGrid => {
                // 将当前网格深拷贝并推入栈中
                savedGridStack.push(JSON.parse(JSON.stringify($userGrid)));
            })();
        },

        // 从栈中加载并设置最新保存的网格
        loadGrid: () => {
            if (savedGridStack.length > 0) {
                const latestGrid = savedGridStack.pop(); // 弹出栈顶元素
                userGrid.set(latestGrid); // 设置当前网格为栈顶的网格
            } else {
                console.warn('No grid to load.');
            }
        },
		
		// 钿哥添加撤销和撤回撤销的功能
		undo: () => {
			history.update($history => {
				historyIndex.update($historyIndex => {
					if ($historyIndex > -1) {
						const { pos, value } = $history[$historyIndex];
						userGrid.update($userGrid => {
							if ($historyIndex + 1 < $history.length) {
								$history[$historyIndex + 1] = { pos: pos, value: $userGrid[pos.y][pos.x] };
							} else {
								$history.push({ pos: pos, value: $userGrid[pos.y][pos.x] });
							}
							$historyIndex--;
							$userGrid[pos.y][pos.x] = value;
							return $userGrid;
						});
					}
					return $historyIndex;
				});
				return $history;
			});
		},

		redo: () => {
			history.update($history => {
				historyIndex.update($historyIndex => {
					if ($historyIndex < $history.length - 2) {
						userGrid.update($userGrid => {
							$historyIndex++;
							const { pos, value } = $history[$historyIndex + 1];
							const valueOld = $userGrid[pos.y][pos.x];
							$history[$historyIndex] = { pos: pos, value: valueOld };
							$userGrid[pos.y][pos.x] = value;
							return $userGrid;
						});
					}
					return $historyIndex;
				});
				return $history;
			});
		},
	};
}

// 常鹏：当前使用的表格
export const userGrid = createUserGrid();

export const invalidCells = derived(userGrid, $userGrid => {
	const _invalidCells = [];

	const addInvalid = (x, y) => {
		const xy = x + ',' + y;
		if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
	};

	for (let y = 0; y < SUDOKU_SIZE; y++) {
		for (let x = 0; x < SUDOKU_SIZE; x++) {

			const value = $userGrid[y][x];

			if (value) {
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					// Check the row
					if (i !== x && $userGrid[y][i] === value) {
						addInvalid(x, y);
					}

					// Check the column
					if (i !== y && $userGrid[i][x] === value) {
						addInvalid(x, i);
					}
				}

				// Check the box
				const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
				const endY = startY + BOX_SIZE;
				const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
				const endX = startX + BOX_SIZE;
				for (let row = startY; row < endY; row++) {
					for (let col = startX; col < endX; col++) {
						if (row !== y && col !== x && $userGrid[row][col] === value) {
							addInvalid(col, row);
						}
					}
				}
			}

		}
	}

	return _invalidCells;
}, []);
