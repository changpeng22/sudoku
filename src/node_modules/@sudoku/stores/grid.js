import { BOX_SIZE, SUDOKU_SIZE,STRATEGY_LIST } from '@sudoku/constants';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveManagement } from '@sudoku/sudoku';
import { derived, writable } from 'svelte/store';
import { hints } from './hints';
// 邱梓钿：导入模块
import { candidates } from './candidates';
import { history } from './history';
import { gameWon } from '@sudoku/stores/game';
import { get } from 'svelte/store';

// 邱梓钿：添加无解判断
export const hasSolution = writable(true);

// 常鹏：显示所使用的策略
export const usedStrategy = writable('');

function createGrid() {
	const grid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	return {
		subscribe: grid.subscribe,

		generate(difficulty) {
			grid.set(generateSudoku(difficulty));
		},

		decodeSencode(sencode) {
			grid.set(decodeSencode(sencode));
		},

		get(gridStore, x, y) {
			return gridStore[y][x];
		},

		getSencode(gridStore) {
			return encodeSudoku(gridStore);
		},
	};
}

export const grid = createGrid();


function createUserGrid() {
	const userGrid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	grid.subscribe($grid => {
		let newGrid = [];

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			newGrid[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				newGrid[y][x] = $grid[y][x];
			}
		}

		userGrid.set(newGrid);
	});

	return {
		subscribe: userGrid.subscribe,

		set: (pos, value, updateHistory = true) => {
			// userGrid.update($userGrid => {
			// 	$userGrid[pos.y][pos.x] = value;
			// 	if (updateHistory) {
			// 		history.addState($userGrid);
			// 	}
			// 	return $userGrid;
			// });
			history.addState(pos.y, pos.x, value);
			userGrid.set(history.getCurrentGrid());
		},

		// 邱梓钿：修改为按照候选值的数量来应用提示
		applyHint: (switchHint = true) => {
			console.log('applyHint');
			let maxCandidateCount = hints.getHint();
			if (switchHint) {
				maxCandidateCount = hints.switchHint();
			}
			candidates.reset();
			if (maxCandidateCount === 0) {
				return;
			}
			userGrid.update($userGrid => {
				// const solvedSudoku = solveSudoku($userGrid);
				const sm = new solveManagement();//王舒航&郭集河：修改为solveManagement类解法
				const [solvedSudoku,list] = sm.solveFrame($userGrid,2);//王舒航&郭集河：修改为solveManagement类解法，并且加上用到的策略列表
				let strategyStr = '';
				list.forEach((item)=>{
					strategyStr += ' --> ' + STRATEGY_LIST[item];
				})
				usedStrategy.set(strategyStr);
				console.log("使用策略：",strategyStr);
				
				// const solvedSudoku = {
				// 	1: [
				// 		[0, 0, [5]],
				// 		[1, 2, [3]]
				// 	],
				// 	2: [
				// 		[0, 1, [1, 2]],
				// 		[2, 2, [4, 6]]
				// 	],
				// 	3: [
				// 		[3, 3, [7, 8, 9]]
				// 	]
				// };
				let allValuesEmpty = true;
				for (let key in solvedSudoku) {
					if (solvedSudoku[key].length > 0) {
						allValuesEmpty = false;
						break;
					}
				}
				if (!get(gameWon)) {
					if (allValuesEmpty) {
						hasSolution.set(false);
						// hints.switchHint(true);
					}
					else {
							hasSolution.set(true);
						}
				}
				for (const [candidateCount, solutions] of Object.entries(solvedSudoku)) {
					const processedPositions = new Set();
					if (candidateCount <= maxCandidateCount) {
						for (const solution of solutions) {
							const [row, col, candidateValues] = solution;
							const positionKey = `${row},${col}`;
							if (!processedPositions.has(positionKey)) {
								candidateValues.forEach(candidate => {
									candidates.add({ x: col, y: row }, candidate);
								});
								// processedPositions.add(positionKey);
							}
						}
					}
				}
				// if (Object.keys(solvedSudoku).length === 0) {
				// 	hasSolution.set(false);
				// 	hints.switchHint(true)
				// }
				// else {
				// 	hasSolution.set(true);
				// }
				// // Iterate over each solution
				// for (const [candidateCount, solutions] of Object.entries(solvedSudoku)) {
				// 	if (candidateCount <= maxCandidateCount) {
				// 		for (const solution of solutions) {
				// 			const [row, col, candidateValues] = solution;
				// 			candidateValues.forEach(candidate => {
				// 				candidates.add({ x: col, y: row }, candidate);
				// 			});
				// 		}
				// 	}
				// }
				return $userGrid;
			});
		},

		// 邱梓钿：添加undo和redo的功能
		undo: () => {
			history.undo();
			userGrid.set(history.getCurrentGrid());
		},

		redo: () => {
			history.redo();
			userGrid.set(history.getCurrentGrid());
		},
		
		backtrack: () => {
			history.backtrack();
			userGrid.set(history.getCurrentGrid());
		},
	};
}

// 常鹏：当前使用的表格
export const userGrid = createUserGrid();

export const invalidCells = derived(userGrid, $userGrid => {
	const _invalidCells = [];

	const addInvalid = (x, y) => {
		const xy = x + ',' + y;
		if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
	};

	for (let y = 0; y < SUDOKU_SIZE; y++) {
		for (let x = 0; x < SUDOKU_SIZE; x++) {

			const value = $userGrid[y][x];

			if (value) {
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					// Check the row
					if (i !== x && $userGrid[y][i] === value) {
						addInvalid(x, y);
					}

					// Check the column
					if (i !== y && $userGrid[i][x] === value) {
						addInvalid(x, i);
					}
				}

				// Check the box
				const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
				const endY = startY + BOX_SIZE;
				const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
				const endX = startX + BOX_SIZE;
				for (let row = startY; row < endY; row++) {
					for (let col = startX; col < endX; col++) {
						if (row !== y && col !== x && $userGrid[row][col] === value) {
							addInvalid(col, row);
						}
					}
				}
			}

		}
	}

	return _invalidCells;
}, []);

// 常鹏：当前单元格所在行、列、宫已填入的数字
export const getFilledNumbers = (pos) => {
		let filledNumbers = new Set();
	
		userGrid.subscribe(($userGrid) => {
	      // 添加所在行和列中的数字
	      for (let i = 0; i < SUDOKU_SIZE; i++) {
	        filledNumbers.add($userGrid[pos.y][i]); // 行
	        filledNumbers.add($userGrid[i][pos.x]); // 列
	      }
	  
	      // 添加所在3x3子宫中的数字
	      const startX = Math.floor(pos.x / BOX_SIZE) * BOX_SIZE; // 宫的起始列
	      const startY = Math.floor(pos.y / BOX_SIZE) * BOX_SIZE; // 宫的起始行
	      for (let i = startY; i < startY + BOX_SIZE; i++) {
			for (let j = startX; j < startX + BOX_SIZE; j++) {
	          filledNumbers.add($userGrid[i][j]); // 添加宫中的数字
			}
	      }
		})();
	  
	    // 删除 0 并返回结果
		return [...filledNumbers].filter((num) => num !== 0);
};
	  