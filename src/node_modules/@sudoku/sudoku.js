//王舒航&郭集河：更改固定变量设置
// const { testSudoku } = require('@sudoku/sencode/index.js');
// input_url = 'https://www.sudokuwiki.org/sudoku.htm?bd=093824560085600002206075008321769845000258300578040296850016723007082650002507180'
// data = testSudoku(input_url);
// import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
// import { getSudoku } from 'fake-sudoku-puzzle-generator';

// var CHUNK_SIZE = 3;
// var ROW_COL_SIZE = CHUNK_SIZE * CHUNK_SIZE; // 9
// var SIZE = ROW_COL_SIZE * ROW_COL_SIZE; // 81
// var single_candidates=[];
// const input = 'bd=400000938032094100095300240370609004529001673604703090957008300003900400240030709';
// const SUDOKU_SIZE = 9;
// const BOX_SIZE = 3;
// const GRID_LENGTH = SUDOKU_SIZE * SUDOKU_SIZE;
// const GRID_COORDS = [
//   [0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8],
//   [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8],
//   [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [2, 5], [2, 6], [2, 7], [2, 8],
//   [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [3, 5], [3, 6], [3, 7], [3, 8],
//   [4, 0], [4, 1], [4, 2], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [4, 8],
//   [5, 0], [5, 1], [5, 2], [5, 3], [5, 4], [5, 5], [5, 6], [5, 7], [5, 8],
//   [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6], [6, 7], [6, 8],
//   [7, 0], [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7], [7, 8],
//   [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [8, 7], [8, 8]
// ];

// const { getSudoku } = require('fake-sudoku-puzzle-generator');
import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';

var CHUNK_SIZE = 3;
var ROW_COL_SIZE = CHUNK_SIZE * CHUNK_SIZE; // 9
var SIZE = ROW_COL_SIZE * ROW_COL_SIZE; // 81
var single_candidates=[];
import { getSudoku } from 'fake-sudoku-puzzle-generator';
/**
 * 解析输入字符串并生成数独谜题
 * @param {string} input - 类似 "bd=093824560085600002206075008321769845000258300578040296850016723007082650002507180" 的输入字符串
 * @returns {number[][]} - 生成的数独谜题（二维数组）
 */
function parseSudokuFromInput(input) {
  // 提取 "bd=" 后面的数独字符串
  const sudokuString = input.split('bd=')[1];

  // 检查输入是否有效
  if (!sudokuString || sudokuString.length !== 81) {
    throw new Error('Invalid input: Sudoku string must be exactly 81 characters long.');
  }

  // 将字符串转换为二维数组
  const sudoku = [];
  for (let i = 0; i < 9; i++) {
    const row = [];
    for (let j = 0; j < 9; j++) {
      const char = sudokuString[i * 9 + j];
      row.push(Number(char)); // 将字符转换为数字
    }
    sudoku.push(row);
  }

  return sudoku;
}
function printSudoku(sudoku, isRow = false) {
  if (isRow) {
    // 打印单行数据
    let out = '║ ';
    for (let col = 0; col < SUDOKU_SIZE; col++) {
      out += (sudoku[col] === 0 ? '·' : sudoku[col]) + ' ';
      if (col % BOX_SIZE === 2) {
        out += '│ ';
      }
    }
    out += '║';
    console.log(out);
  } else {
    // 打印整个数独
    let out = '╔═══════╤═══════╤═══════╗\n';
    for (let row = 0; row < SUDOKU_SIZE; row++) {
      if (row !== 0 && row % BOX_SIZE === 0) {
        out += '╟───────┼───────┼───────╢\n';
      }
      out += '║ ';
      for (let col = 0; col < SUDOKU_SIZE; col++) {
        out += (sudoku[row][col] === 0 ? '·' : sudoku[row][col]) + ' ';
        if (col % BOX_SIZE === 2) {
          out += '│ ';
        }
      }
      out += '║\n';
    }
    out += '╚═══════╧═══════╧═══════╝';
    console.log(out);
  }
}
//检查重构，完成任务
'use strict';

var CHUNK_SIZE = 3;
var ROW_COL_SIZE = CHUNK_SIZE * CHUNK_SIZE; // 9
var SIZE = ROW_COL_SIZE * ROW_COL_SIZE; // 81


// 执行测试
// testSolveSudoku();

export function generateSudoku(difficulty = 'easy') {
	const sudoku = getSudoku(difficulty);

	for (let row = 0; row < SUDOKU_SIZE; row++) {
		for (let col = 0; col < SUDOKU_SIZE; col++) {
			if (sudoku[row][col] === null) sudoku[row][col] = 0;
		}
	}

	return sudoku;
}
export class solveManagement
{
  constructor() {
    this.strategies = [];
    this.hs = new HiddenSingle();
    this.np= new NakedPairs();
    this.nt= new NakedTriples();
    this.hp= new HiddenPairs();
    this.ht = new HiddenTriples();
    this.hq= new HiddenQuads();
    this.nq = new NakedQuads();
    this.addStrategy(this.hs);
    this.addStrategy(this.np);
    this.addStrategy(this.nt);
    this.addStrategy(this.hp);
    this.addStrategy(this.ht);
    this.addStrategy(this.hq);
    this.addStrategy(this.nq);
  }
  
  addStrategy(strategy) {
    this.strategies.push(strategy);
  }
  // 王舒航&郭集河：初始化候选值列表
  initializeCandidates(sudoku) {
    const candidates = [];
    for (let row = 0; row < ROW_COL_SIZE; row++) {
      const rowCandidates = [];
      for (let col = 0; col < ROW_COL_SIZE; col++) {
        if (sudoku[row][col] === 0) {
          rowCandidates.push(this.getCandidates(sudoku, row, col));
        } else {
          rowCandidates.push([]); // 已填数字的候选值为空
        }
      }
      candidates.push(rowCandidates);
    }
    return candidates;
  }
  
    // 王舒航&郭集河：更新候选值列表
   
    // 王舒航&郭集河：获取候选值
    getCandidates(puzzle, row, col) {
      const used = new Set();
    
      // 检查行
      for (let c = 0; c < ROW_COL_SIZE; c++) {
        if (puzzle[row][c] !== 0) {
          used.add(puzzle[row][c]);
        }
      }
    
      // 检查列
      for (let r = 0; r < ROW_COL_SIZE; r++) {
        if (puzzle[r][col] !== 0) {
          used.add(puzzle[r][col]);
        }
      }
    
      // 检查 3x3 宫
      const boxRowStart = Math.floor(row / CHUNK_SIZE) * CHUNK_SIZE;
      const boxColStart = Math.floor(col / CHUNK_SIZE) * CHUNK_SIZE;
      for (let r = boxRowStart; r < boxRowStart + CHUNK_SIZE; r++) {
        for (let c = boxColStart; c < boxColStart + CHUNK_SIZE; c++) {
          if (puzzle[r][c] !== 0) {
            used.add(puzzle[r][c]);
          }
        }
      }
    
      // 候选值 = 全部可能值 - 已使用值
      return [...Array(ROW_COL_SIZE).keys()].map((x) => x + 1).filter((x) => !used.has(x));
    }
    
  
    // 获取 3x3 宫的值
    getBox(puzzle, boxRow, boxCol) {
      const box = [];
      for (let i = boxRow * CHUNK_SIZE; i < (boxRow + 1) * CHUNK_SIZE; i++) {
        for (let j = boxCol * CHUNK_SIZE; j < (boxCol + 1) * CHUNK_SIZE; j++) {
          box.push(puzzle[i][j]);
        }
      }
      return box;
    }
    
  // 获取 3x3 宫的候选值
  getBoxCandidates(candidates, boxRow, boxCol) {
    const boxCandidates = [];
    for (let i = boxRow * CHUNK_SIZE; i < (boxRow + 1) * CHUNK_SIZE; i++) {
      for (let j = boxCol * CHUNK_SIZE; j < (boxCol + 1) * CHUNK_SIZE; j++) {
        boxCandidates.push(candidates[i][j]);
      }
    }
    return boxCandidates;
  }
  
  solveFrame(sudoku,check) {
    single_candidates=[];
    if (!Array.isArray(sudoku) || !Array.isArray(sudoku[0])) {
      throw new Error('Invalid Sudoku format. Expected a 2D array.');
    }
  
    // 初始化候选值列表
    const candidates = this.initializeCandidates(sudoku);
  
    // 将二维数组转换为一维数组
    const flatSudoku = [].concat(...sudoku);
  
    // 检查行数
    const rows = flatSudoku.length;
  
    const solvedSudoku0 = {};
  
    for (let row = 0; row < ROW_COL_SIZE; row++) {
      for (let col = 0; col < ROW_COL_SIZE; col++) {
        const cellCandidates = candidates[row][col];
        if (cellCandidates.length > 0) {
          const key = cellCandidates.length; // 候选值的个数作为键
          if (!solvedSudoku0[key]) {
            solvedSudoku0[key] = [];
          }
          solvedSudoku0[key].push([row, col, cellCandidates]);
        }
      }
    }
    console.log("Number of candidates before solving the sudoku");
    // printNumCandidates(solvedSudoku0) ;
    // 核心解决数独函数
    // const solution = this.solveAll(flatSudoku, {
    //   outputArray: true,
    //   hintCheck: false,
    // }, candidates);
    const queue = this.solveAll(flatSudoku, {
      outputArray: true,
      hintCheck: false,
    }, candidates);
  

  
    const solvedSudoku = {};
  
    for (let row = 0; row < ROW_COL_SIZE; row++) {
      for (let col = 0; col < ROW_COL_SIZE; col++) {
        const cellCandidates = candidates[row][col];
        if (cellCandidates.length > 0) {
          const key = cellCandidates.length; // 候选值的个数作为键
          // console.log('key', key);
          if (!solvedSudoku[key]) {
            solvedSudoku[key] = [];
          }
          solvedSudoku[key].push([row, col, cellCandidates]);
          console.log('row', row, 'col', col, 'cellCandidates', cellCandidates);
        }
      }
    }
  
    // printNumCandidates(solvedSudoku) ;
  
  //   solvedSudoku[1]=[];
    
    solvedSudoku[1]=[];
    for (let i = 0; i < single_candidates.length; i++) {
    const [row, col, candidate] = single_candidates[i];
    console.log('sc row', row, 'col', col, 'cellCandidates', candidate);
    solvedSudoku[1].push([row, col, [candidate]]);
    }
    
    if(check==0)
      {
    this.saveResult(solvedSudoku);
  }
    if(check==1)
      {
    this.compareSudokuWithSaved(solvedSudoku);
    }
  
    // console.log("Number of candidates after solving the sudoku");
    // console.log(solvedSudoku);
    // console.log(queue);
    return [solvedSudoku,queue]; 
  }
  // 工具函数：将一维数组转换为二维数组
  chunkArray(array, chunkSize) {
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  }
  
  saveResult(sudoku) {
    const fs = require('fs');

    // 将 solvedSudoku 转换为 JSON 字符串
    const jsonContent = JSON.stringify(sudoku);
    
    // 将 JSON 字符串写入文件
    fs.writeFile('solvedSudoku.json', jsonContent, 'utf8', (err) => {
      if (err) {
        console.error('写入文件时发生错误:', err);
      } else {
        console.log('solvedSudoku 已成功保存到 solvedSudoku.json');
      }
    });
  }

  

  compareSudokuWithSaved(solvedSudoku) {
    // 读取之前保存的文件
    const fs = require('fs');
    fs.readFile('solvedSudoku.json', 'utf8', (err, data) => {
      if (err) {
        console.error('读取文件时发生错误:', err);
        return;
      }

      try {
        // 将读取到的 JSON 字符串解析为对象
        const savedSudoku = JSON.parse(data);

        // 比较两个数独对象是否相同
        const isEqual = JSON.stringify(solvedSudoku) === JSON.stringify(savedSudoku);

        if (isEqual) {
          console.log('solvedSudoku 与保存的文件完全相同');
        } else {
          console.log('solvedSudoku 与保存的文件不相同');
        }
      } catch (parseErr) {
        console.error('解析 JSON 时发生错误:', parseErr);
      }
    });
  }


  
  solveAll(puzzle, options, candidates) {
    var opts = {
      emptyValue: '0', // 使用 '0' 表示空格
      hintCheck: true, // 是否检查最小提示数
      outputArray: false, // 返回值是否为数组
      maxIterations: 1, // 最大迭代次数
    };

    if (options !== undefined) {
      Object.assign(opts, options);
    }

    if (typeof puzzle === 'string') {
      puzzle = puzzle.split('');
    }

    if (!Array.isArray(puzzle)) {
      throw new TypeError('Puzzle must be string or array.');
    }

    if (puzzle.length !== SIZE) {
      throw new Error('Puzzle is an invalid size.');
    }

    let hints = 0;
    puzzle = puzzle.map((element) => {
      if (element === opts.emptyValue || element === parseInt(opts.emptyValue, 10)) {
        return 0;
      }
      hints++;
      const value = parseInt(element, 10);
      if (isNaN(value) || value > 9 || value < 1) {
        throw new TypeError('Invalid puzzle value: ' + element);
      }
      return value;
    });

    if (opts.hintCheck && hints < 17) {
      throw new Error('A valid puzzle must have at least 17 hints.');
    }

    puzzle = this.chunkArray(puzzle, ROW_COL_SIZE);

    let iterations = 0;
    // printCandidates(candidates);
    const queue = []; // 定义一个队列

    while (iterations < opts.maxIterations) {
      let progress = false;
      // console.log('first function');
      for (let i = 0; i < this.strategies.length; i++) {
        console.log(i);
        if (this.strategies[i].solve(puzzle, candidates)) {
          progress = true;
          if(progress)
          console.log('Strategy', this.strategies[i].name, 'succeeded.');
          else
          console.log('Strategy', this.strategies[i].name, 'failed.');
          queue.push(i); // 将成功的策略索引 i 入队

          // continue;
          // printSudoku(puzzle);
        }
        // // console.log('second function');
      }


      if (!progress) {
        console.log('No progress made.');
        break;

      }

      iterations++;
    }
    console.log('Queue of successful strategies:', queue);
    console.log('Number of iterations:', iterations);
    // return opts.outputArray ? puzzle : puzzle.join('');
    return queue;
  }

  

    
  
}

class baseStrategy {
  constructor() {
    this.name = 'Base Strategy';
  }

  // 王舒航&郭集河：更新候选值列表
  updateCandidates(puzzle, candidates, row, col, value) {
    candidates[row][col] = []; // 已填数字的候选值为空
   
    
    console.log(`Filling sc (${row}, ${col}) with ${value}`);
    single_candidates.push([row,col,value]);
    // 更新行中的候选值
    for (let c = 0; c < ROW_COL_SIZE; c++) {
      if (c !== col && puzzle[row][c] === 0 ) {
        candidates[row][c] = candidates[row][c].filter(candidate => candidate !== value);
      }
    }
  
    // 更新列中的候选值
    for (let r = 0; r < ROW_COL_SIZE; r++) {
      if (r !== row && puzzle[r][col] === 0) {
        candidates[r][col] = candidates[r][col].filter(candidate => candidate !== value);
      }
    }
  
    // 更新宫中的候选值
    const boxRow = Math.floor(row / CHUNK_SIZE) * CHUNK_SIZE;
    const boxCol = Math.floor(col / CHUNK_SIZE) * CHUNK_SIZE;
    for (let r = boxRow; r < boxRow + CHUNK_SIZE; r++) {
      for (let c = boxCol; c < boxCol + CHUNK_SIZE; c++) {
        if ((r !== row || c !== col) && puzzle[r][c] === 0) { // 只更新未填单元格        
          candidates[r][c] = candidates[r][c].filter(candidate => candidate !== value);
        }
      }
    }
  
    //王舒航&郭集河： 打印候选值表
    console.log(`Updated candidates after filling (${row}, ${col}) with ${value}:`);
    // printCandidates(candidates);
    printSudoku(puzzle);
  }

 


  
 getBoxCandidates(candidates, boxRow, boxCol) {
  const boxCandidates = [];
  for (let i = boxRow * CHUNK_SIZE; i < (boxRow + 1) * CHUNK_SIZE; i++) {
    for (let j = boxCol * CHUNK_SIZE; j < (boxCol + 1) * CHUNK_SIZE; j++) {
      boxCandidates.push(candidates[i][j]);
    }
  }
  return boxCandidates;
}

  applyStrategy(puzzle, candidates, groupType, fixedRow, fixedCol) {
    
  }
  solve(puzzle, candidates) {
    let each_progress = false;
    for (let row = 0; row < ROW_COL_SIZE; row++) {
      if (this.applyStrategy(puzzle, candidates, 'row', row, null)) {
        each_progress = true;
      }
    }
  
    // 对每一列应用 Naked Pairs
    for (let col = 0; col < ROW_COL_SIZE; col++) {
      if (this.applyStrategy(puzzle, candidates, 'column', null, col)) {
        each_progress = true;
      }
    }
  
    // 对每一个 3x3 宫应用 Naked Pairs
    for (let boxRow = 0; boxRow < CHUNK_SIZE; boxRow++) {
      for (let boxCol = 0; boxCol < CHUNK_SIZE; boxCol++) {
        if (this.applyStrategy(puzzle, candidates, 'box', boxRow, boxCol)) {
          each_progress = true;
        }
      }
    }
    return each_progress;
  }
}

class HiddenSingle extends baseStrategy {
  constructor() {
    super('Hidden Single');
  }
  findUniqueCandidates(candidates) {
    const SUDOKU_SIZE = 9;
    const uniqueCandidates = [];
  
    // 统计每个候选数的出现次数
    const candidateCount = Array.from({ length: SUDOKU_SIZE + 1 }, () => 0);
    for (let i = 0; i < candidates.length; i++) {
      for (const candidate of candidates[i]) {
        candidateCount[candidate]++;
      }
    }
  
    // 查找只出现一次的候选数
    for (let i = 0; i < candidates.length; i++) {
      for (const candidate of candidates[i]) {
        if (candidateCount[candidate] === 1) {
          uniqueCandidates.push([candidate, i]);
        }
      }
    }
  
    return uniqueCandidates;
  }
  applyStrategy(puzzle, candidates, groupType, fixedRow, fixedCol) {
    let progress = false;
    
  // 根据 groupType 提取当前行、列或宫格的候选值
  let groupCandidates;
  if (groupType === 'row') {
    groupCandidates = candidates[fixedRow];
  } else if (groupType === 'column') {
    groupCandidates = candidates.map((row) => row[fixedCol]);
  } else if (groupType === 'box') {
    groupCandidates = this.getBoxCandidates(candidates, fixedRow, fixedCol);
  }

  // 查找唯一的候选数
  const uniqueCandidates = this.findUniqueCandidates(groupCandidates);

  // 处理唯一的候选数
  for (const [candidate, index] of uniqueCandidates) {
    let row, col;
    if (groupType === 'row') {
      row = fixedRow;
      col = index;
    } else if (groupType === 'column') {
      row = index;
      col = fixedCol;
    } else if (groupType === 'box') {
      row = fixedRow * CHUNK_SIZE + Math.floor(index / CHUNK_SIZE);
      col = fixedCol * CHUNK_SIZE + (index % CHUNK_SIZE);
    }

    if (puzzle[row][col] === 0) { // 只修改空单元格
      puzzle[row][col] = candidate; // 填入唯一值
      this.updateCandidates(puzzle, candidates, row, col, candidate);
      console.log(`Filled [${row}, ${col}] with Hidden Singles (${groupType})`);
      progress = true;
    }
  }

  return progress;
  }
  }


class NakedPairs extends baseStrategy {
    constructor() {
      super('Naked Pairs');
    }
    applyStrategy(puzzle, candidates, groupType, fixedRow, fixedCol){
      let progress = false;

  // 根据 groupType 提取当前行、列或宫格的候选值
  let groupCandidates;
  if (groupType === 'row') {
    groupCandidates = candidates[fixedRow];
  } else if (groupType === 'column') {
    groupCandidates = candidates.map((row) => row[fixedCol]);
  } else if (groupType === 'box') {
    groupCandidates = this.getBoxCandidates(candidates, fixedRow, fixedCol);
  }

  // 遍历候选值，查找 Naked Pairs
  for (let i = 0; i < groupCandidates.length; i++) {
    for (let j = i + 1; j < groupCandidates.length; j++) {
      const current = groupCandidates[i];
      const next = groupCandidates[j];

      // 检查是否是 Naked Pair
      if (current.length === 2 && current.length === next.length && current.every((x) => next.includes(x))) {
        const pair = current;

        // 剔除其他候选值
        for (let index = 0; index < groupCandidates.length; index++) {
          if (index !== i && index !== j) {
            let row, col;
            if (groupType === 'row') {
              row = fixedRow;
              col = index;
            } else if (groupType === 'column') {
              row = index;
              col = fixedCol;
            } else if (groupType === 'box') {
              row = fixedRow * CHUNK_SIZE + Math.floor(index / CHUNK_SIZE);
              col = fixedCol * CHUNK_SIZE + (index % CHUNK_SIZE);
            }

            if (puzzle[row][col] === 0) { // 只修改空单元格
              for (const candidate of pair) {
                if (candidates[row][col].includes(candidate)) {
                  candidates[row][col] = candidates[row][col].filter((c) => c !== candidate);
                  progress = true;

                  // 如果某个单元格的候选值变为 1，填入该值
                  if (candidates[row][col].length === 1) {
                    const value = candidates[row][col][0];
                    puzzle[row][col] = value;
                    this.updateCandidates(puzzle, candidates, row, col, value);
                    console.log('filled sudoku with Naked Pairs');
                  }
                }
              }
            }
          }
        }
      }
    }
  }
    }
    }
class NakedTriples extends baseStrategy {
      constructor() {
        super('Naked Tripless');
      }
      applyStrategy(puzzle, candidates, groupType, fixedRow, fixedCol){
        let progress = false;
    
        // 根据 groupType 提取当前行、列或宫格的候选值
        let groupCandidates;
        if (groupType === 'row') {
          groupCandidates = candidates[fixedRow];
        } else if (groupType === 'column') {
          groupCandidates = candidates.map((row) => row[fixedCol]);
        } else if (groupType === 'box') {
          groupCandidates = this.getBoxCandidates(candidates, fixedRow, fixedCol);
        }
      
        // 遍历候选值，查找 Naked Pairs
        for (let i = 0; i < groupCandidates.length; i++) {
          for (let j = i + 1; j < groupCandidates.length; j++) {
            const current = groupCandidates[i];
            const next = groupCandidates[j];
      
            // 检查是否是 Naked Pair
            if (current.length === 2 && current.length === next.length && current.every((x) => next.includes(x))) {
              const pair = current;
      
              // 剔除其他候选值
              for (let index = 0; index < groupCandidates.length; index++) {
                if (index !== i && index !== j) {
                  let row, col;
                  if (groupType === 'row') {
                    row = fixedRow;
                    col = index;
                  } else if (groupType === 'column') {
                    row = index;
                    col = fixedCol;
                  } else if (groupType === 'box') {
                    row = fixedRow * CHUNK_SIZE + Math.floor(index / CHUNK_SIZE);
                    col = fixedCol * CHUNK_SIZE + (index % CHUNK_SIZE);
                  }
      
                  if (puzzle[row][col] === 0) { // 只修改空单元格
                    for (const candidate of pair) {
                      if (candidates[row][col].includes(candidate)) {
                        candidates[row][col] = candidates[row][col].filter((c) => c !== candidate);
                        progress = true;
      
                        // 如果某个单元格的候选值变为 1，填入该值
                        if (candidates[row][col].length === 1) {
                          const value = candidates[row][col][0];
                          puzzle[row][col] = value;
                          this.updateCandidates(puzzle, candidates, row, col, value);
                          console.log('filled sudoku with Naked Pairs');
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      
        return progress;
      }
    
    }
class NakedQuads extends baseStrategy {
      constructor() {
        super('Naked Quads');
      }
      applyStrategy(puzzle, candidates, groupType, fixedRow, fixedCol){
        let progress = false;
    
        // 根据 groupType 提取当前行、列或宫格的候选值
        let groupCandidates;
        if (groupType === 'row') {
          groupCandidates = candidates[fixedRow];
        } else if (groupType === 'column') {
          groupCandidates = candidates.map((row) => row[fixedCol]);
        } else if (groupType === 'box') {
          groupCandidates = this.getBoxCandidates(candidates, fixedRow, fixedCol);
        }
      
        // 遍历候选值，查找 Naked Quads
        for (let i = 0; i < groupCandidates.length; i++) {
          for (let j = i + 1; j < groupCandidates.length; j++) {
            for (let k = j + 1; k < groupCandidates.length; k++) {
              for (let l = k + 1; l < groupCandidates.length; l++) {
                const current = groupCandidates[i];
                const next = groupCandidates[j];
                const third = groupCandidates[k];
                const fourth = groupCandidates[l];
      
                // 检查是否是 Naked Quad
                if (
                  (current.length === 2 || current.length === 3 || current.length === 4) &&
                  (next.length === 2 || next.length === 3 || next.length === 4) &&
                  (third.length === 2 || third.length === 3 || third.length === 4) &&
                  (fourth.length === 2 || fourth.length === 3 || fourth.length === 4) &&
                  new Set([...current, ...next, ...third, ...fourth]).size === 4
                ) {
                  const quad = [...new Set([...current, ...next, ...third, ...fourth])];
      
                  // 剔除其他候选值
                  for (let index = 0; index < groupCandidates.length; index++) {
                    if (index !== i && index !== j && index !== k && index !== l) {
                      let row, col;
                      if (groupType === 'row') {
                        row = fixedRow;
                        col = index;
                      } else if (groupType === 'column') {
                        row = index;
                        col = fixedCol;
                      } else if (groupType === 'box') {
                        row = fixedRow * CHUNK_SIZE + Math.floor(index / CHUNK_SIZE);
                        col = fixedCol * CHUNK_SIZE + (index % CHUNK_SIZE);
                      }
      
                      if (puzzle[row][col] === 0) { // 只修改空单元格
                        for (const candidate of quad) {
                          if (candidates[row][col].includes(candidate)) {
                            candidates[row][col] = candidates[row][col].filter((c) => c !== candidate);
                            progress = true;
      
                            // 如果某个单元格的候选值变为 1，填入该值
                            if (candidates[row][col].length === 1) {
                              const value = candidates[row][col][0];
                              puzzle[row][col] = value;
                              this.updateCandidates(puzzle, candidates, row, col, value);
                              console.log('filled sudoku with Naked Quads');
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      
        return progress;
      }
    
    }
class HiddenPairs extends baseStrategy {
      constructor() {
        super('Hidden Pairs');
      }
      findHiddenPairs(candidates) {
        const SUDOKU_SIZE = 9;
        const hiddenPairs = [];
      
        // 遍历所有可能的配对
        for (let i = 0; i < SUDOKU_SIZE; i++) {
          for (let j = i + 1; j < SUDOKU_SIZE; j++) {
            const pair = [i + 1, j + 1]; // 配对
            const cells = [];
      
            // 检查这些候选数是否只出现在同一组单元格中
            for (let index = 0; index < candidates.length; index++) {
              const cellCandidates = candidates[index];
      
              // 检查单元格的候选数是否包含配对中的至少一个数字
              if (pair.some(num => cellCandidates.includes(num))) {
                cells.push(index);
              }
            }
      
            // 如果配对中的数字只出现在两个单元格中，且这两个单元格的候选数包含配对中的所有数字
            if (cells.length === 2) {
              const [cell1, cell2] = cells;
              const cell1Candidates = candidates[cell1];
              const cell2Candidates = candidates[cell2];
      
              // 检查这两个单元格的候选数是否都包含配对中的所有数字
              if (pair.every(num => cell1Candidates.includes(num)) &&
                  pair.every(num => cell2Candidates.includes(num))) {
                hiddenPairs.push([pair, cells]);
              }
            }
          }
        }
      
        return hiddenPairs;
      }
      applyStrategy(puzzle, candidates, groupType, fixedRow, fixedCol) {
        let progress = false;
    
        // 根据 groupType 提取当前行、列或宫格的候选值
        let groupCandidates;
        if (groupType === 'row') {
          groupCandidates = candidates[fixedRow];
        } else if (groupType === 'column') {
          groupCandidates = candidates.map((row) => row[fixedCol]);
        } else if (groupType === 'box') {
          groupCandidates = this.getBoxCandidates(candidates, fixedRow, fixedCol);
        }
      
        // 查找 Hidden Pairs
        const hiddenPairs = this.findHiddenPairs(groupCandidates);
      
        // 处理 Hidden Pairs
        for (const [pair, indices] of hiddenPairs) {
          // 确保 Hidden Pair 的两个单元格的候选数完全匹配
          if (indices.length === 2) {
            const [index1, index2] = indices;
      
            // 获取两个单元格的候选数
            const cell1 = groupCandidates[index1];
            const cell2 = groupCandidates[index2];
      
            // 如果两个单元格的候选数完全相同，则剔除其他候选数
            if (cell1.length > 2 && cell2.length > 2 && cell1.every((x) => cell2.includes(x))) {
              // 更新两个单元格的候选数为 Hidden Pair
              groupCandidates[index1] = pair;
              groupCandidates[index2] = pair;
      
              // 更新原始 candidates 数组
              if (groupType === 'row') {
                candidates[fixedRow][index1] = pair;
                candidates[fixedRow][index2] = pair;
              } else if (groupType === 'column') {
                candidates[index1][fixedCol] = pair;
                candidates[index2][fixedCol] = pair;
              } else if (groupType === 'box') {
                const row1 = fixedRow * CHUNK_SIZE + Math.floor(index1 / CHUNK_SIZE);
                const col1 = fixedCol * CHUNK_SIZE + (index1 % CHUNK_SIZE);
                const row2 = fixedRow * CHUNK_SIZE + Math.floor(index2 / CHUNK_SIZE);
                const col2 = fixedCol * CHUNK_SIZE + (index2 % CHUNK_SIZE);
                candidates[row1][col1] = pair;
                candidates[row2][col2] = pair;
              }
      
              console.log(`Found Hidden Pair [${pair}] at indices ${indices} in ${groupType}`);
              progress = true;
            }
          }
        }
      
        return progress;
      }
    }
class HiddenTriples extends baseStrategy {
        constructor() {
          super('Hidden Triples');
        }
        findHiddenTriples(candidates) {
          const SUDOKU_SIZE = 9;
          const hiddenTriples = [];
        
          // 遍历所有可能的三元组
          for (let i = 0; i < SUDOKU_SIZE; i++) {
            for (let j = i + 1; j < SUDOKU_SIZE; j++) {
              for (let k = j + 1; k < SUDOKU_SIZE; k++) {
                const triple = [i + 1, j + 1, k + 1]; // 三元组
                const cells = [];
        
                // 检查这些候选数是否只出现在同一组单元格中
                for (let index = 0; index < candidates.length; index++) {
                  const cellCandidates = candidates[index];
        
                  // 检查单元格的候选数是否包含三元组中的至少一个数字
                  if (triple.some(num => cellCandidates.includes(num))) {
                    cells.push(index);
                  }
                }
        
                // 如果三元组只出现在三个单元格中，且这三个单元格的候选数包含三元组中的所有数字
                if (cells.length === 3) {
                  const [cell1, cell2, cell3] = cells;
                  const cell1Candidates = candidates[cell1];
                  const cell2Candidates = candidates[cell2];
                  const cell3Candidates = candidates[cell3];
        
                  // 检查这三个单元格的候选数是否都包含三元组中的所有数字
                  if (triple.every(num => cell1Candidates.includes(num)) &&
                      triple.every(num => cell2Candidates.includes(num)) &&
                      triple.every(num => cell3Candidates.includes(num))) {
                    hiddenTriples.push([triple, cells]);
                  }
                }
              }
            }
          }
        
          return hiddenTriples;
        }
        applyStrategy(puzzle, candidates, groupType, fixedRow, fixedCol) {
          let progress = false;
      
          // 根据 groupType 提取当前行、列或宫格的候选值
          let groupCandidates;
          if (groupType === 'row') {
            groupCandidates = candidates[fixedRow];
          } else if (groupType === 'column') {
            groupCandidates = candidates.map((row) => row[fixedCol]);
          } else if (groupType === 'box') {
            groupCandidates = this.getBoxCandidates(candidates, fixedRow, fixedCol);
          }
        
          // 查找 Hidden Pairs
          const hiddenPairs = this.findHiddenTriples(groupCandidates);
        
          // 处理 Hidden Pairs
          for (const [pair, indices] of hiddenPairs) {
            // 确保 Hidden Pair 的两个单元格的候选数完全匹配
            if (indices.length === 2) {
              const [index1, index2] = indices;
        
              // 获取两个单元格的候选数
              const cell1 = groupCandidates[index1];
              const cell2 = groupCandidates[index2];
        
              // 如果两个单元格的候选数完全相同，则剔除其他候选数
              if (cell1.length > 2 && cell2.length > 2 && cell1.every((x) => cell2.includes(x))) {
                // 更新两个单元格的候选数为 Hidden Pair
                groupCandidates[index1] = pair;
                groupCandidates[index2] = pair;
        
                // 更新原始 candidates 数组
                if (groupType === 'row') {
                  candidates[fixedRow][index1] = pair;
                  candidates[fixedRow][index2] = pair;
                } else if (groupType === 'column') {
                  candidates[index1][fixedCol] = pair;
                  candidates[index2][fixedCol] = pair;
                } else if (groupType === 'box') {
                  const row1 = fixedRow * CHUNK_SIZE + Math.floor(index1 / CHUNK_SIZE);
                  const col1 = fixedCol * CHUNK_SIZE + (index1 % CHUNK_SIZE);
                  const row2 = fixedRow * CHUNK_SIZE + Math.floor(index2 / CHUNK_SIZE);
                  const col2 = fixedCol * CHUNK_SIZE + (index2 % CHUNK_SIZE);
                  candidates[row1][col1] = pair;
                  candidates[row2][col2] = pair;
                }
        
                console.log(`Found Hidden Pair [${pair}] at indices ${indices} in ${groupType}`);
                progress = true;
              }
            }
          }
        
          return progress;
        }
    }
class HiddenQuads extends baseStrategy {
          constructor() {
            super('Hidden Quads');
          }
          findHiddenQuads(candidates) {
            const SUDOKU_SIZE = 9;
            const hiddenQuads = [];
          
            // 遍历所有可能的四元组
            for (let i = 0; i < SUDOKU_SIZE; i++) {
              for (let j = i + 1; j < SUDOKU_SIZE; j++) {
                for (let k = j + 1; k < SUDOKU_SIZE; k++) {
                  for (let l = k + 1; l < SUDOKU_SIZE; l++) {
                    const quad = [i + 1, j + 1, k + 1, l + 1]; // 四元组
                    const cells = [];
          
                    // 检查这些候选数是否只出现在同一组单元格中
                    for (let index = 0; index < candidates.length; index++) {
                      const cellCandidates = candidates[index];
          
                      // 检查单元格的候选数是否包含四元组中的至少一个数字
                      if (quad.some(num => cellCandidates.includes(num))) {
                        cells.push(index);
                      }
                    }
          
                    // 如果四元组只出现在四个单元格中，且这四个单元格的候选数包含四元组中的所有数字
                    if (cells.length === 4) {
                      const [cell1, cell2, cell3, cell4] = cells;
                      const cell1Candidates = candidates[cell1];
                      const cell2Candidates = candidates[cell2];
                      const cell3Candidates = candidates[cell3];
                      const cell4Candidates = candidates[cell4];
          
                      // 检查这四个单元格的候选数是否都包含四元组中的所有数字
                      if (quad.every(num => cell1Candidates.includes(num)) &&
                          quad.every(num => cell2Candidates.includes(num)) &&
                          quad.every(num => cell3Candidates.includes(num)) &&
                          quad.every(num => cell4Candidates.includes(num))) {
                        hiddenQuads.push([quad, cells]);
                      }
                    }
                  }
                }
              }
            }
          
            return hiddenQuads;
          }
          
          applyStrategy(puzzle, candidates, groupType, fixedRow, fixedCol) {
            let progress = false;
        
            // 根据 groupType 提取当前行、列或宫格的候选值
            let groupCandidates;
            if (groupType === 'row') {
              groupCandidates = candidates[fixedRow];
            } else if (groupType === 'column') {
              groupCandidates = candidates.map((row) => row[fixedCol]);
            } else if (groupType === 'box') {
              groupCandidates = this.getBoxCandidates(candidates, fixedRow, fixedCol);
            }
          
            // 查找 Hidden Quads
            const hiddenQuads = this.findHiddenQuads(groupCandidates);
          
            // 处理 Hidden Quads
            for (const [quad, indices] of hiddenQuads) {
              // 确保 Hidden Quad 的四个单元格的候选数完全匹配
              if (indices.length === 4) {
                const [index1, index2, index3, index4] = indices;
          
                // 获取四个单元格的候选数
                const cell1 = groupCandidates[index1];
                const cell2 = groupCandidates[index2];
                const cell3 = groupCandidates[index3];
                const cell4 = groupCandidates[index4];
          
                // 如果四个单元格的候选数完全相同，则剔除其他候选数
                if (
                  cell1.length > 4 &&
                  cell2.length > 4 &&
                  cell3.length > 4 &&
                  cell4.length > 4 &&
                  cell1.every((x) => quad.includes(x)) &&
                  cell2.every((x) => quad.includes(x)) &&
                  cell3.every((x) => quad.includes(x)) &&
                  cell4.every((x) => quad.includes(x))
                ) {
                  // 更新四个单元格的候选数为 Hidden Quad
                  groupCandidates[index1] = quad;
                  groupCandidates[index2] = quad;
                  groupCandidates[index3] = quad;
                  groupCandidates[index4] = quad;
          
                  // 更新原始 candidates 数组
                  if (groupType === 'row') {
                    candidates[fixedRow][index1] = quad;
                    candidates[fixedRow][index2] = quad;
                    candidates[fixedRow][index3] = quad;
                    candidates[fixedRow][index4] = quad;
                  } else if (groupType === 'column') {
                    candidates[index1][fixedCol] = quad;
                    candidates[index2][fixedCol] = quad;
                    candidates[index3][fixedCol] = quad;
                    candidates[index4][fixedCol] = quad;
                  } else if (groupType === 'box') {
                    const row1 = fixedRow * CHUNK_SIZE + Math.floor(index1 / CHUNK_SIZE);
                    const col1 = fixedCol * CHUNK_SIZE + (index1 % CHUNK_SIZE);
                    const row2 = fixedRow * CHUNK_SIZE + Math.floor(index2 / CHUNK_SIZE);
                    const col2 = fixedCol * CHUNK_SIZE + (index2 % CHUNK_SIZE);
                    const row3 = fixedRow * CHUNK_SIZE + Math.floor(index3 / CHUNK_SIZE);
                    const col3 = fixedCol * CHUNK_SIZE + (index3 % CHUNK_SIZE);
                    const row4 = fixedRow * CHUNK_SIZE + Math.floor(index4 / CHUNK_SIZE);
                    const col4 = fixedCol * CHUNK_SIZE + (index4 % CHUNK_SIZE);
                    candidates[row1][col1] = quad;
                    candidates[row2][col2] = quad;
                    candidates[row3][col3] = quad;
                    candidates[row4][col4] = quad;
                  }
          
                  console.log(`Found Hidden Quad [${quad}] at indices ${indices} in ${groupType}`);
                  progress = true;
                }
              }
            }
          
            return progress;  
          }
    }     
    
   
// function testSolveSudokuOO() {
//             console.log('Generating Sudoku puzzle...');
//             // const sudoku = generateSudoku('medium'); // 生成中等难度数独
//             const sudoku = parseSudokuFromInput(input);
            
//             console.log('\nGenerated Sudoku puzzle:');
//             printSudoku(sudoku); // 打印生成的数独
          
//             console.log('\nSolving Sudoku...');
            
//             sm=new solveManagement();
            
//             const [a,b]=sm.solveFrame(sudoku,2);
//             console.log(a);
//             console.log(b);
            
//     }
//           // 执行测试
// // testSolveSudokuOO();   
        