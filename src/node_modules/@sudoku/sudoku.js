//王舒航&郭集河：更改固定变量设置
const SUDOKU_SIZE = 9;
const BOX_SIZE = 3;
const GRID_LENGTH = SUDOKU_SIZE * SUDOKU_SIZE;
const GRID_COORDS = [
  [0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8],
  [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8],
  [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [2, 5], [2, 6], [2, 7], [2, 8],
  [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [3, 5], [3, 6], [3, 7], [3, 8],
  [4, 0], [4, 1], [4, 2], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [4, 8],
  [5, 0], [5, 1], [5, 2], [5, 3], [5, 4], [5, 5], [5, 6], [5, 7], [5, 8],
  [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6], [6, 7], [6, 8],
  [7, 0], [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7], [7, 8],
  [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [8, 7], [8, 8]
];

const { getSudoku } = require('fake-sudoku-puzzle-generator');

module.exports = {
  generateSudoku,
  solveSudoku,
  printSudoku,
};

'use strict';

var CHUNK_SIZE = 3;
var ROW_COL_SIZE = CHUNK_SIZE * CHUNK_SIZE; // 9
var SIZE = ROW_COL_SIZE * ROW_COL_SIZE; // 81

/**
 * @param {('veryeasy' | 'easy' | 'medium' | 'hard')} difficulty
 * @returns {number[][]}
 */
function generateSudoku(difficulty = 'easy') {
  let sudoku = getSudoku(difficulty);
  for (let row = 0; row < SUDOKU_SIZE; row++) {
    for (let col = 0; col < SUDOKU_SIZE; col++) {
      if (sudoku[row][col] === null) sudoku[row][col] = 0;
    }
  }
  return sudoku;
}

/**
 * @param {number[][]} sudoku
 */
//王舒航&郭集河：更改求解逻辑
function solveSudoku(sudoku) {
  if (!Array.isArray(sudoku) || !Array.isArray(sudoku[0])) {
    throw new Error('Invalid Sudoku format. Expected a 2D array.');
  }

  // 初始化候选值列表
  const candidates = initializeCandidates(sudoku);

  // 将二维数组转换为一维数组
  const flatSudoku = [].concat(...sudoku);

  // 检查行数
  const rows = flatSudoku.length;

  const solvedSudoku0 = {};

  for (let row = 0; row < ROW_COL_SIZE; row++) {
    for (let col = 0; col < ROW_COL_SIZE; col++) {
      const cellCandidates = candidates[row][col];
      if (cellCandidates.length > 0) {
        const key = cellCandidates.length; // 候选值的个数作为键
        if (!solvedSudoku0[key]) {
          solvedSudoku0[key] = [];
        }
        solvedSudoku0[key].push([row, col, cellCandidates]);
      }
    }
  }
  console.log("Number of candidates before solving the sudoku");
  printNumCandidates(solvedSudoku0) ;
  // 核心解决数独函数
  const solution = solve(flatSudoku, {
    outputArray: true,
    hintCheck: false,
  }, candidates);

  // let grid = [
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  // ];

  // for (let cell = 0; cell < GRID_LENGTH; cell++) {
  //   const [row, col] = GRID_COORDS[cell];
  //   grid[row][col] = solution[cell];
  // }

  // return grid;

  const solvedSudoku = {};

  for (let row = 0; row < ROW_COL_SIZE; row++) {
    for (let col = 0; col < ROW_COL_SIZE; col++) {
      const cellCandidates = candidates[row][col];
      if (cellCandidates.length > 0) {
        const key = cellCandidates.length; // 候选值的个数作为键
        if (!solvedSudoku[key]) {
          solvedSudoku[key] = [];
        }
        solvedSudoku[key].push([row, col, cellCandidates]);
      }
    }
  }
  console.log("Number of candidates after solving the sudoku");
  printNumCandidates(solvedSudoku) ;

  return solvedSudoku;
}
//王舒航&郭集河：更改固定变量设置
function  printNumCandidates(solvedSudoku) {
  console.log('{');
  for (const [key, cells] of Object.entries(solvedSudoku)) {
    console.log(`  "${key}": [`);
    cells.forEach(([row, col, candidates], index) => {
      const formattedCandidates = `[${candidates.join(', ')}]`;
      console.log(
        `    [${row}, ${col}, ${formattedCandidates}]${index < cells.length - 1 ? ',' : ''}`
      );
    });
    console.log('  ],');
  }
  console.log('}');
}



/**
 * @param {number[][]} sudoku
 */
function printSudoku(sudoku, isRow = false) {
  if (isRow) {
    // 打印单行数据
    let out = '║ ';
    for (let col = 0; col < SUDOKU_SIZE; col++) {
      out += (sudoku[col] === 0 ? '·' : sudoku[col]) + ' ';
      if (col % BOX_SIZE === 2) {
        out += '│ ';
      }
    }
    out += '║';
    console.log(out);
  } else {
    // 打印整个数独
    let out = '╔═══════╤═══════╤═══════╗\n';
    for (let row = 0; row < SUDOKU_SIZE; row++) {
      if (row !== 0 && row % BOX_SIZE === 0) {
        out += '╟───────┼───────┼───────╢\n';
      }
      out += '║ ';
      for (let col = 0; col < SUDOKU_SIZE; col++) {
        out += (sudoku[row][col] === 0 ? '·' : sudoku[row][col]) + ' ';
        if (col % BOX_SIZE === 2) {
          out += '│ ';
        }
      }
      out += '║\n';
    }
    out += '╚═══════╧═══════╧═══════╝';
    console.log(out);
  }
}
// 王舒航&郭集河：核心解决数独函数
function solve(puzzle, options, candidates) {
  var opts = {
    emptyValue: '0', // 使用 '0' 表示空格
    hintCheck: true, // 是否检查最小提示数
    outputArray: false, // 返回值是否为数组
    maxIterations: 500, // 最大迭代次数
  };

  if (options !== undefined) {
    Object.assign(opts, options);
  }

  if (typeof puzzle === 'string') {
    puzzle = puzzle.split('');
  }

  if (!Array.isArray(puzzle)) {
    throw new TypeError('Puzzle must be string or array.');
  }

  if (puzzle.length !== SIZE) {
    throw new Error('Puzzle is an invalid size.');
  }

  let hints = 0;
  puzzle = puzzle.map((element) => {
    if (element === opts.emptyValue || element === parseInt(opts.emptyValue, 10)) {
      return 0;
    }
    hints++;
    const value = parseInt(element, 10);
    if (isNaN(value) || value > 9 || value < 1) {
      throw new TypeError('Invalid puzzle value: ' + element);
    }
    return value;
  });

  if (opts.hintCheck && hints < 17) {
    throw new Error('A valid puzzle must have at least 17 hints.');
  }

  puzzle = chunkArray(puzzle, ROW_COL_SIZE);

  let iterations = 0;
  // printCandidates(candidates);

  while (iterations < opts.maxIterations) {
    let progress = false;
	  // console.log('first function');

    if (applyHiddenSingles(puzzle, 0, candidates)) {
      progress = true;
      // printSudoku(puzzle);
    }
	  // console.log('second function');

    if (applyNakedPairsTriples(puzzle, candidates)) {
      progress = true;
      // printSudoku(puzzle);
    }
    if (!progress) {
      break;
    }

    iterations++;
  }

  return opts.outputArray ? puzzle : puzzle.join('');
}

// 王舒航&郭集河：添加自动测试功能
function testSolveSudoku() {
  console.log('Generating Sudoku puzzle...');
  const sudoku = generateSudoku('veryeasy'); // 生成中等难度数独

  console.log('\nGenerated Sudoku puzzle:');
  printSudoku(sudoku); // 打印生成的数独

  console.log('\nSolving Sudoku...');
  try {
    const solution = solveSudoku(sudoku); // 调用 solveSudoku 方法解决数独
    // console.log('\nSolved Sudoku:');
    // printSudoku(solution); // 打印解决后的数独
  } catch (error) {
    console.error('\nFailed to solve Sudoku:', error.message);
  }
}

// 工具函数：将一维数组转换为二维数组
function chunkArray(array, chunkSize) {
  const chunks = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    chunks.push(array.slice(i, i + chunkSize));
  }
  return chunks;
}

function isSolved(puzzle) {
  return puzzle.every((row) => row.every((cell) => cell !== 0));
}

//王舒航&郭集河： Hidden Singles 的实现
function applyHiddenSingles(puzzle, emptyValue, candidates) {
  let progress = false;
  for (let row = 0; row < ROW_COL_SIZE; row++) {
    for (let col = 0; col < ROW_COL_SIZE; col++) {
      if (puzzle[row][col] === emptyValue) {
        const cellCandidates = candidates[row][col];
        if (cellCandidates.length === 1) {
          puzzle[row][col] = cellCandidates[0]; // 填入唯一值
          // console.log('first function solved');
          printSudoku(puzzle);
          updateCandidates(puzzle, candidates, row, col, cellCandidates[0]);
          progress = true;
          return progress;
        }
      }
    }
  }
  // console.log('no only one candidate');
  return progress;
}

//王舒航&郭集河： Naked Pairs/Triples 的实现
function applyNakedPairsTriples(puzzle, candidates) {
  let progress = false;
  // printSudoku(puzzle);
  // printCandidates(candidates);
  // 对每一行应用规则
  for (let row = 0; row < ROW_COL_SIZE; row++) {
    // printSudoku(puzzle[row], true); // 传入单行数据
    // printCandidates(candidates[row], true);
    if (applyNakedRule(puzzle[row], candidates[row])) {
      progress = true;
    }
  }

  // 对每一列应用规则
  for (let col = 0; col < ROW_COL_SIZE; col++) {
    const column = puzzle.map((row) => row[col]);
    const columnCandidates = candidates.map((row) => row[col]);
    if (applyNakedRule(column, columnCandidates)) {
      progress = true;
      column.forEach((val, i) => {
        if (puzzle[i][col] === 0) { // 只修改空单元格
          puzzle[i][col] = val;
        }
      });
    }
  }

  // 对每一个 3x3 宫应用规则
  for (let boxRow = 0; boxRow < CHUNK_SIZE; boxRow++) {
    for (let boxCol = 0; boxCol < CHUNK_SIZE; boxCol++) {
      const box = getBox(puzzle, boxRow, boxCol);
      const boxCandidates = getBoxCandidates(candidates, boxRow, boxCol);
      if (applyNakedRule(box, boxCandidates)) {
        let index = 0;
        for (let i = boxRow * CHUNK_SIZE; i < (boxRow + 1) * CHUNK_SIZE; i++) {
          for (let j = boxCol * CHUNK_SIZE; j < (boxCol + 1) * CHUNK_SIZE; j++) {
            if (puzzle[i][j] === 0) { // 只修改空单元格
              puzzle[i][j] = box[index++];
            }
          }
        }
        progress = true;
      }
    }
  }

  return progress;
}

// 王舒航&郭集河：初始化候选值列表
function initializeCandidates(sudoku) {
  const candidates = [];
  for (let row = 0; row < ROW_COL_SIZE; row++) {
    const rowCandidates = [];
    for (let col = 0; col < ROW_COL_SIZE; col++) {
      if (sudoku[row][col] === 0) {
        rowCandidates.push(getCandidates(sudoku, row, col));
      } else {
        rowCandidates.push([]); // 已填数字的候选值为空
      }
    }
    candidates.push(rowCandidates);
  }
  return candidates;
}

// 王舒航&郭集河：更新候选值列表
function updateCandidates(puzzle, candidates, row, col, value) {
  candidates[row][col] = []; // 已填数字的候选值为空

  // 更新行中的候选值
  for (let c = 0; c < ROW_COL_SIZE; c++) {
    if (c !== col) {
      candidates[row][c] = candidates[row][c].filter(candidate => candidate !== value);
    }
  }

  // 更新列中的候选值
  for (let r = 0; r < ROW_COL_SIZE; r++) {
    if (r !== row) {
      candidates[r][col] = candidates[r][col].filter(candidate => candidate !== value);
    }
  }

  // 更新宫中的候选值
  const boxRow = Math.floor(row / CHUNK_SIZE) * CHUNK_SIZE;
  const boxCol = Math.floor(col / CHUNK_SIZE) * CHUNK_SIZE;
  for (let r = boxRow; r < boxRow + CHUNK_SIZE; r++) {
    for (let c = boxCol; c < boxCol + CHUNK_SIZE; c++) {
      if (r !== row || c !== col) {
        candidates[r][c] = candidates[r][c].filter(candidate => candidate !== value);
      }
    }
  }

  //王舒航&郭集河： 打印候选值表
  console.log(`Updated candidates after filling (${row}, ${col}) with ${value}:`);
  // printCandidates(candidates);
  printSudoku(puzzle);
}

// 王舒航&郭集河：获取候选值
function getCandidates(puzzle, row, col) {
  const used = new Set();

  // 检查行
  for (let c = 0; c < ROW_COL_SIZE; c++) {
    if (puzzle[row][c] !== 0) {
      used.add(puzzle[row][c]);
    }
  }

  // 检查列
  for (let r = 0; r < ROW_COL_SIZE; r++) {
    if (puzzle[r][col] !== 0) {
      used.add(puzzle[r][col]);
    }
  }

  // 检查 3x3 宫
  const boxRowStart = Math.floor(row / CHUNK_SIZE) * CHUNK_SIZE;
  const boxColStart = Math.floor(col / CHUNK_SIZE) * CHUNK_SIZE;
  for (let r = boxRowStart; r < boxRowStart + CHUNK_SIZE; r++) {
    for (let c = boxColStart; c < boxColStart + CHUNK_SIZE; c++) {
      if (puzzle[r][c] !== 0) {
        used.add(puzzle[r][c]);
      }
    }
  }

  // 候选值 = 全部可能值 - 已使用值
  return [...Array(ROW_COL_SIZE).keys()].map((x) => x + 1).filter((x) => !used.has(x));
}

//王舒航&郭集河： Naked Pairs/Triples 规则的实现
function applyNakedRule(values, candidates) {
  let progress = false;

  // 检查是否存在共享候选值的对/三元组
  for (let i = 0; i < candidates.length; i++) {
    const current = candidates[i];
    for (let j = i + 1; j < candidates.length; j++) {
      const next = candidates[j];
      if (current.length === next.length && current.every((x) => next.includes(x))) {
        const pair = current;
        // console.log('Naked pair or triple found:', pair);
        if (pair.length <= 3) {
          // 剔除其他候选值
          for (let index = 0; index < candidates.length; index++) {
            if (index !== i && index !== j && values[index] === 0) {
              for (const candidate of pair) {
                if (Array.isArray(candidates[index]) && pair.every(candidate => candidates[index].includes(candidate))) {
                  candidates[index] = candidates[index].filter(c => c !== candidate);
                  progress = true;

                  // 如果某个单元格的候选值变为 1，填入该值
                  if (candidates[index].length === 1) {
                    values[index] = candidates[index][0];
                    console.log('second function');
                    updateCandidates(values, candidates, index, 0, values[index]);
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return progress;
}

// 获取 3x3 宫的值
function getBox(puzzle, boxRow, boxCol) {
  const box = [];
  for (let i = boxRow * CHUNK_SIZE; i < (boxRow + 1) * CHUNK_SIZE; i++) {
    for (let j = boxCol * CHUNK_SIZE; j < (boxCol + 1) * CHUNK_SIZE; j++) {
      box.push(puzzle[i][j]);
    }
  }
  return box;
}

// 获取 3x3 宫的候选值
function getBoxCandidates(candidates, boxRow, boxCol) {
  const boxCandidates = [];
  for (let i = boxRow * CHUNK_SIZE; i < (boxRow + 1) * CHUNK_SIZE; i++) {
    for (let j = boxCol * CHUNK_SIZE; j < (boxCol + 1) * CHUNK_SIZE; j++) {
      boxCandidates.push(candidates[i][j]);
    }
  }
  return boxCandidates;
}

//王舒航&郭集河： 打印候选值表
function printCandidates(candidates, isRow = false) {
  if (isRow) {
    // 打印单行数据
    let out = '║ ';
    for (let col = 0; col < SUDOKU_SIZE; col++) {
      out += `[${candidates[col].join(',')}] `;
      if (col % BOX_SIZE === 2) {
        out += '│ ';
      }
    }
    out += '║';
    console.log(out);
  } else {
    // 打印整个候选值表
    console.log('Candidate Table:');
    for (let row = 0; row < ROW_COL_SIZE; row++) {
      let rowString = '';
      for (let col = 0; col < ROW_COL_SIZE; col++) {
        rowString += `[${candidates[row][col].join(',')}] `;
      }
      console.log(rowString);
    }
    console.log('---------------------------------');
  }
}

// 执行测试
testSolveSudoku();