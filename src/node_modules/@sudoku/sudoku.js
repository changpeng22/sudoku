//王舒航&郭集河：更改固定变量设置
// const { testSudoku } = require('@sudoku/sencode/index.js');
// input_url = 'https://www.sudokuwiki.org/sudoku.htm?bd=093824560085600002206075008321769845000258300578040296850016723007082650002507180'
// data = testSudoku(input_url);
import { BOX_SIZE, GRID_LENGTH, SUDOKU_SIZE, GRID_COORDS } from '@sudoku/constants';
import { getSudoku } from 'fake-sudoku-puzzle-generator';

var CHUNK_SIZE = 3;
var ROW_COL_SIZE = CHUNK_SIZE * CHUNK_SIZE; // 9
var SIZE = ROW_COL_SIZE * ROW_COL_SIZE; // 81
var single_candidates=[];

export function generateSudoku(difficulty = 'easy') {
	const sudoku = getSudoku(difficulty);

	for (let row = 0; row < SUDOKU_SIZE; row++) {
		for (let col = 0; col < SUDOKU_SIZE; col++) {
			if (sudoku[row][col] === null) sudoku[row][col] = 0;
		}
	}

	return sudoku;
}
/**
 * 解析输入字符串并生成数独谜题
 * @param {string} input - 类似 "bd=093824560085600002206075008321769845000258300578040296850016723007082650002507180" 的输入字符串
 * @returns {number[][]} - 生成的数独谜题（二维数组）
 */
function parseSudokuFromInput(input) {
  // 提取 "bd=" 后面的数独字符串
  const sudokuString = input.split('bd=')[1];

  // 检查输入是否有效
  if (!sudokuString || sudokuString.length !== 81) {
    throw new Error('Invalid input: Sudoku string must be exactly 81 characters long.');
  }

  // 将字符串转换为二维数组
  const sudoku = [];
  for (let i = 0; i < 9; i++) {
    const row = [];
    for (let j = 0; j < 9; j++) {
      const char = sudokuString[i * 9 + j];
      row.push(Number(char)); // 将字符转换为数字
    }
    sudoku.push(row);
  }

  return sudoku;
}



/**
 * @param {number[][]} sudoku
 */
//王舒航&郭集河：更改求解逻辑
export function solveSudoku(sudoku) {
  if (!Array.isArray(sudoku) || !Array.isArray(sudoku[0])) {
    throw new Error('Invalid Sudoku format. Expected a 2D array.');
  }

  // 初始化候选值列表
  const candidates = initializeCandidates(sudoku);

  // 将二维数组转换为一维数组
  const flatSudoku = [].concat(...sudoku);

  // 检查行数
  const rows = flatSudoku.length;

  const solvedSudoku0 = {};

  for (let row = 0; row < ROW_COL_SIZE; row++) {
    for (let col = 0; col < ROW_COL_SIZE; col++) {
      const cellCandidates = candidates[row][col];
      if (cellCandidates.length > 0) {
        const key = cellCandidates.length; // 候选值的个数作为键
        if (!solvedSudoku0[key]) {
          solvedSudoku0[key] = [];
        }
        solvedSudoku0[key].push([row, col, cellCandidates]);
      }
    }
  }
  console.log("Number of candidates before solving the sudoku");
  printNumCandidates(solvedSudoku0) ;
  // 核心解决数独函数
  const solution = solve(flatSudoku, {
    outputArray: true,
    hintCheck: false,
  }, candidates);

  // let grid = [
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 0, 0, 0, 0],
  // ];

  // for (let cell = 0; cell < GRID_LENGTH; cell++) {
  //   const [row, col] = GRID_COORDS[cell];
  //   grid[row][col] = solution[cell];
  // }

  // return grid;

  const solvedSudoku = {};

  for (let row = 0; row < ROW_COL_SIZE; row++) {
    for (let col = 0; col < ROW_COL_SIZE; col++) {
      const cellCandidates = candidates[row][col];
      if (cellCandidates.length > 0) {
        const key = cellCandidates.length; // 候选值的个数作为键
        // console.log('key', key);
        if (!solvedSudoku[key]) {
          solvedSudoku[key] = [];
        }
        solvedSudoku[key].push([row, col, cellCandidates]);
        console.log('row', row, 'col', col, 'cellCandidates', cellCandidates);
      }
    }
  }

  // printNumCandidates(solvedSudoku) ;

//   solvedSudoku[1]=[];
  
  solvedSudoku[1]=[];
  for (let i = 0; i < single_candidates.length; i++) {
	const [row, col, candidate] = single_candidates[i];
  console.log('sc row', row, 'col', col, 'cellCandidates', candidate);
	solvedSudoku[1].push([row, col, [candidate]]);
  }
  
	

// 	  solvedSudoku[1].push([a[0],a[1],[a[2]]]);
	
//   }
  // console.log("Number of candidates after solving the sudoku");
  // printNumCandidates(solvedSudoku) ;
  // console.log(solvedSudoku);
  // console.log("Expected output form");
  // 	const solvedSudoku1 = {
	// 				1: [
	// 					[0, 0, [5]],
	// 					[1, 2, [3]]
	// 				],
	// 				2: [
	// 					[0, 1, [1, 2]],
	// 					[2, 2, [4, 6]]
	// 				],
	// 				3: [
	// 					[3, 3, [7, 8, 9]]
	// 				]
	// 			};
  //       console.log(solvedSudoku1);
  console.log("Number of candidates after solving the sudoku");
  console.log(solvedSudoku);
  return solvedSudoku;
}
//王舒航&郭集河：更改固定变量设置
function  printNumCandidates(solvedSudoku) {
  console.log('{');
  for (const [key, cells] of Object.entries(solvedSudoku)) {
    console.log(`  ${key}: [`);
    cells.forEach(([row, col, candidates], index) => {
      const formattedCandidates = `[${candidates.join(', ')}]`;
      console.log(
        `    [${row}, ${col}, ${formattedCandidates}]${index < cells.length - 1 ? ',' : ''}`
      );
    });
    console.log('  ],');
  }
  console.log('}');
}



/**
 * @param {number[][]} sudoku
 */
export function printSudoku(sudoku, isRow = false) {
  if (isRow) {
    // 打印单行数据
    let out = '║ ';
    for (let col = 0; col < SUDOKU_SIZE; col++) {
      out += (sudoku[col] === 0 ? '·' : sudoku[col]) + ' ';
      if (col % BOX_SIZE === 2) {
        out += '│ ';
      }
    }
    out += '║';
    console.log(out);
  } else {
    // 打印整个数独
    let out = '╔═══════╤═══════╤═══════╗\n';
    for (let row = 0; row < SUDOKU_SIZE; row++) {
      if (row !== 0 && row % BOX_SIZE === 0) {
        out += '╟───────┼───────┼───────╢\n';
      }
      out += '║ ';
      for (let col = 0; col < SUDOKU_SIZE; col++) {
        out += (sudoku[row][col] === 0 ? '·' : sudoku[row][col]) + ' ';
        if (col % BOX_SIZE === 2) {
          out += '│ ';
        }
      }
      out += '║\n';
    }
    out += '╚═══════╧═══════╧═══════╝';
    console.log(out);
  }
}
// 王舒航&郭集河：核心解决数独函数
function solve(puzzle, options, candidates) {
  var opts = {
    emptyValue: '0', // 使用 '0' 表示空格
    hintCheck: true, // 是否检查最小提示数
    outputArray: false, // 返回值是否为数组
    maxIterations: 100, // 最大迭代次数
  };

  if (options !== undefined) {
    Object.assign(opts, options);
  }

  if (typeof puzzle === 'string') {
    puzzle = puzzle.split('');
  }

  if (!Array.isArray(puzzle)) {
    throw new TypeError('Puzzle must be string or array.');
  }

  if (puzzle.length !== SIZE) {
    throw new Error('Puzzle is an invalid size.');
  }

  let hints = 0;
  puzzle = puzzle.map((element) => {
    if (element === opts.emptyValue || element === parseInt(opts.emptyValue, 10)) {
      return 0;
    }
    hints++;
    const value = parseInt(element, 10);
    if (isNaN(value) || value > 9 || value < 1) {
      throw new TypeError('Invalid puzzle value: ' + element);
    }
    return value;
  });

  if (opts.hintCheck && hints < 17) {
    throw new Error('A valid puzzle must have at least 17 hints.');
  }

  puzzle = chunkArray(puzzle, ROW_COL_SIZE);

  let iterations = 0;
  // printCandidates(candidates);

  while (iterations < opts.maxIterations) {
    let progress = false;
	  // console.log('first function');

    if (applyHiddenSingles(puzzle, 0, candidates)) {
      progress = true;
      // continue;
      // printSudoku(puzzle);
    }
	  // // console.log('second function');

    if (applyNakedPairs(puzzle, candidates)) {
      progress = true;
      // continue;

      // printSudoku(puzzle);
    }
    if (applyNakedTriples(puzzle, candidates)) {
      progress = true;
      // continue;

      // printSudoku(puzzle);
    }
    
    if (applyHiddenPairs(puzzle, candidates)) {
      progress = true;
    
      // printSudoku(puzzle);
    }

    if (applyHiddenTriples(puzzle, candidates)) {
      progress = true;
      // printSudoku(puzzle);
    }

    

    if (applyNakedQuads(puzzle, candidates)) {
      progress = true;
      // printSudoku(puzzle);
    }


    if (applyHiddenQuads(puzzle, candidates)) {
      progress = true;
      // printSudoku(puzzle);
    }

    if (!progress) {
      console.log('No progress made.');
      break;

    }

    iterations++;
  }
  console.log('Number of iterations:', iterations);
  return opts.outputArray ? puzzle : puzzle.join('');
}



// 工具函数：将一维数组转换为二维数组
function chunkArray(array, chunkSize) {
  const chunks = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    chunks.push(array.slice(i, i + chunkSize));
  }
  return chunks;
}

function isSolved(puzzle) {
  return puzzle.every((row) => row.every((cell) => cell !== 0));
}

//王舒航&郭集河： Hidden Singles 的实现
/**
 * 应用 Hidden Singles 策略
 * @param {number[][]} puzzle - 当前的数独谜题（二维数组）
 * @param {number} emptyValue - 空单元格的值（通常为 0）
 * @param {number[][][]} candidates - 每个单元格的候选数（二维数组）
 * @returns {boolean} - 如果策略成功应用，返回 true；否则返回 false
 */
function applyHiddenSingles(puzzle, emptyValue, candidates) {
  const SUDOKU_SIZE = 9;
  let progress = false;

  // 检查每一行
  for (let row = 0; row < SUDOKU_SIZE; row++) {
    const rowCandidates = candidates[row];
    const uniqueCandidates = findUniqueCandidates(rowCandidates);

    for (const [candidate, col] of uniqueCandidates) {
      puzzle[row][col] = candidate; // 填入唯一值
      updateCandidates(puzzle, candidates, row, col, candidate);
      console.log('filled sudoku with Hidden Singles row');
      progress = true;
    }
  }

  // 检查每一列
  for (let col = 0; col < SUDOKU_SIZE; col++) {
    const columnCandidates = candidates.map(row => row[col]);
    const uniqueCandidates = findUniqueCandidates(columnCandidates);

    for (const [candidate, row] of uniqueCandidates) {

      puzzle[row][col] = candidate; // 填入唯一值
      updateCandidates(puzzle, candidates, row, col, candidate);
      console.log('filled sudoku with Hidden Singles column');
      progress = true;
    }
  }

  // 检查每一个 3x3 宫
  for (let boxRow = 0; boxRow < 3; boxRow++) {
    for (let boxCol = 0; boxCol < 3; boxCol++) {
      const boxCandidates = [];
      for (let row = boxRow * 3; row < (boxRow + 1) * 3; row++) {
        for (let col = boxCol * 3; col < (boxCol + 1) * 3; col++) {
          boxCandidates.push(candidates[row][col]);
        }
      }

      const uniqueCandidates = findUniqueCandidates(boxCandidates);

      for (const [candidate, index] of uniqueCandidates) {
        const row = boxRow * 3 + Math.floor(index / 3);
        const col = boxCol * 3 + (index % 3);
        puzzle[row][col] = candidate; // 填入唯一值
        updateCandidates(puzzle, candidates, row, col, candidate);

        console.log('filled sudoku with Hidden Singles box');
        progress = true;
      }
    }
  }

  return progress;
}

/**
 * 查找唯一的候选数
 * @param {number[][]} candidates - 一组单元格的候选数
 * @returns {Array<[number, number]>} - 返回唯一的候选数及其对应的单元格索引
 */
function findUniqueCandidates(candidates) {
  const SUDOKU_SIZE = 9;
  const uniqueCandidates = [];

  // 统计每个候选数的出现次数
  const candidateCount = Array.from({ length: SUDOKU_SIZE + 1 }, () => 0);
  for (let i = 0; i < candidates.length; i++) {
    for (const candidate of candidates[i]) {
      candidateCount[candidate]++;
    }
  }

  // 查找只出现一次的候选数
  for (let i = 0; i < candidates.length; i++) {
    for (const candidate of candidates[i]) {
      if (candidateCount[candidate] === 1) {
        uniqueCandidates.push([candidate, i]);
      }
    }
  }

  return uniqueCandidates;
}

//王舒航&郭集河： Naked Pairs/Triples 的实现
function applyNakedPairs(puzzle, candidates) {
  let progress = false;

  // 对每一行应用 Naked Pairs
  for (let row = 0; row < ROW_COL_SIZE; row++) {
    if (applyNakedPairsInGroup(puzzle, candidates, 'row', row, null)) {
      progress = true;
    }
  }

  // 对每一列应用 Naked Pairs
  for (let col = 0; col < ROW_COL_SIZE; col++) {
    if (applyNakedPairsInGroup(puzzle, candidates, 'column', null, col)) {
      progress = true;
    }
  }

  // 对每一个 3x3 宫应用 Naked Pairs
  for (let boxRow = 0; boxRow < CHUNK_SIZE; boxRow++) {
    for (let boxCol = 0; boxCol < CHUNK_SIZE; boxCol++) {
      if (applyNakedPairsInGroup(puzzle, candidates, 'box', boxRow, boxCol)) {
        progress = true;
      }
    }
  }

  return progress;
}
// 在单个行、列或宫中应用 Naked Pairs
function applyNakedPairsInGroup(puzzle, candidates, groupType, fixedRow, fixedCol) {
  let progress = false;

  // 根据 groupType 提取当前行、列或宫格的候选值
  let groupCandidates;
  if (groupType === 'row') {
    groupCandidates = candidates[fixedRow];
  } else if (groupType === 'column') {
    groupCandidates = candidates.map((row) => row[fixedCol]);
  } else if (groupType === 'box') {
    groupCandidates = getBoxCandidates(candidates, fixedRow, fixedCol);
  }

  // 遍历候选值，查找 Naked Pairs
  for (let i = 0; i < groupCandidates.length; i++) {
    for (let j = i + 1; j < groupCandidates.length; j++) {
      const current = groupCandidates[i];
      const next = groupCandidates[j];

      // 检查是否是 Naked Pair
      if (current.length === 2 && current.length === next.length && current.every((x) => next.includes(x))) {
        const pair = current;

        // 剔除其他候选值
        for (let index = 0; index < groupCandidates.length; index++) {
          if (index !== i && index !== j) {
            let row, col;
            if (groupType === 'row') {
              row = fixedRow;
              col = index;
            } else if (groupType === 'column') {
              row = index;
              col = fixedCol;
            } else if (groupType === 'box') {
              row = fixedRow * CHUNK_SIZE + Math.floor(index / CHUNK_SIZE);
              col = fixedCol * CHUNK_SIZE + (index % CHUNK_SIZE);
            }

            if (puzzle[row][col] === 0) { // 只修改空单元格
              for (const candidate of pair) {
                if (candidates[row][col].includes(candidate)) {
                  candidates[row][col] = candidates[row][col].filter((c) => c !== candidate);
                  progress = true;

                  // 如果某个单元格的候选值变为 1，填入该值
                  if (candidates[row][col].length === 1) {
                    const value = candidates[row][col][0];
                    puzzle[row][col] = value;
                    updateCandidates(puzzle, candidates, row, col, value);
                    console.log('filled sudoku with Naked Pairs');
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return progress;
}

function applyNakedTriples(puzzle, candidates) {
  let progress = false;

  // 对每一行应用 Naked Triples
  for (let row = 0; row < ROW_COL_SIZE; row++) {
    if (applyNakedTriplesInGroup(puzzle, candidates, 'row', row, null)) {
      progress = true;
    }
  }

  // 对每一列应用 Naked Triples
  for (let col = 0; col < ROW_COL_SIZE; col++) {
    if (applyNakedTriplesInGroup(puzzle, candidates, 'column', null, col)) {
      progress = true;
    }
  }

  // 对每一个 3x3 宫应用 Naked Triples
  for (let boxRow = 0; boxRow < CHUNK_SIZE; boxRow++) {
    for (let boxCol = 0; boxCol < CHUNK_SIZE; boxCol++) {
      if (applyNakedTriplesInGroup(puzzle, candidates, 'box', boxRow, boxCol)) {
        progress = true;
      }
    }
  }

  return progress;
}
function applyNakedTriplesInGroup(puzzle, candidates, groupType, fixedRow, fixedCol) {
  let progress = false;

  // 根据 groupType 提取当前行、列或宫格的候选值
  let groupCandidates;
  if (groupType === 'row') {
    groupCandidates = candidates[fixedRow];
  } else if (groupType === 'column') {
    groupCandidates = candidates.map((row) => row[fixedCol]);
  } else if (groupType === 'box') {
    groupCandidates = getBoxCandidates(candidates, fixedRow, fixedCol);
  }

  // 遍历候选值，查找 Naked Triples
  for (let i = 0; i < groupCandidates.length; i++) {
    for (let j = i + 1; j < groupCandidates.length; j++) {
      for (let k = j + 1; k < groupCandidates.length; k++) {
        const current = groupCandidates[i];
        const next = groupCandidates[j];
        const third = groupCandidates[k];

        // 检查是否是 Naked Triple
        if (
          (current.length === 2 || current.length === 3) &&
          (next.length === 2 || next.length === 3) &&
          (third.length === 2 || third.length === 3) &&
          new Set([...current, ...next, ...third]).size === 3
        ) {
          const triple = [...new Set([...current, ...next, ...third])];

          // 剔除其他候选值
          for (let index = 0; index < groupCandidates.length; index++) {
            if (index !== i && index !== j && index !== k) {
              let row, col;
              if (groupType === 'row') {
                row = fixedRow;
                col = index;
              } else if (groupType === 'column') {
                row = index;
                col = fixedCol;
              } else if (groupType === 'box') {
                row = fixedRow * CHUNK_SIZE + Math.floor(index / CHUNK_SIZE);
                col = fixedCol * CHUNK_SIZE + (index % CHUNK_SIZE);
              }

              if (puzzle[row][col] === 0) { // 只修改空单元格
                for (const candidate of triple) {
                  if (candidates[row][col].includes(candidate)) {
                    candidates[row][col] = candidates[row][col].filter((c) => c !== candidate);
                    progress = true;

                    // 如果某个单元格的候选值变为 1，填入该值
                    if (candidates[row][col].length === 1) {
                      const value = candidates[row][col][0];
                      puzzle[row][col] = value;
                      updateCandidates(puzzle, candidates, row, col, value);
                      console.log('filled sudoku with Naked Triples');
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return progress;
}

function applyNakedQuads(puzzle, candidates) {
  let progress = false;

  // 对每一行应用 Naked Quads
  for (let row = 0; row < ROW_COL_SIZE; row++) {
    if (applyNakedQuadsInGroup(puzzle, candidates, 'row', row, null)) {
      progress = true;
    }
  }

  // 对每一列应用 Naked Quads
  for (let col = 0; col < ROW_COL_SIZE; col++) {
    if (applyNakedQuadsInGroup(puzzle, candidates, 'column', null, col)) {
      progress = true;
    }
  }

  // 对每一个 3x3 宫应用 Naked Quads
  for (let boxRow = 0; boxRow < CHUNK_SIZE; boxRow++) {
    for (let boxCol = 0; boxCol < CHUNK_SIZE; boxCol++) {
      if (applyNakedQuadsInGroup(puzzle, candidates, 'box', boxRow, boxCol)) {
        progress = true;
      }
    }
  }

  return progress;
}
function applyNakedQuadsInGroup(puzzle, candidates, groupType, fixedRow, fixedCol) {
  let progress = false;

  // 根据 groupType 提取当前行、列或宫格的候选值
  let groupCandidates;
  if (groupType === 'row') {
    groupCandidates = candidates[fixedRow];
  } else if (groupType === 'column') {
    groupCandidates = candidates.map((row) => row[fixedCol]);
  } else if (groupType === 'box') {
    groupCandidates = getBoxCandidates(candidates, fixedRow, fixedCol);
  }

  // 遍历候选值，查找 Naked Quads
  for (let i = 0; i < groupCandidates.length; i++) {
    for (let j = i + 1; j < groupCandidates.length; j++) {
      for (let k = j + 1; k < groupCandidates.length; k++) {
        for (let l = k + 1; l < groupCandidates.length; l++) {
          const current = groupCandidates[i];
          const next = groupCandidates[j];
          const third = groupCandidates[k];
          const fourth = groupCandidates[l];

          // 检查是否是 Naked Quad
          if (
            (current.length === 2 || current.length === 3 || current.length === 4) &&
            (next.length === 2 || next.length === 3 || next.length === 4) &&
            (third.length === 2 || third.length === 3 || third.length === 4) &&
            (fourth.length === 2 || fourth.length === 3 || fourth.length === 4) &&
            new Set([...current, ...next, ...third, ...fourth]).size === 4
          ) {
            const quad = [...new Set([...current, ...next, ...third, ...fourth])];

            // 剔除其他候选值
            for (let index = 0; index < groupCandidates.length; index++) {
              if (index !== i && index !== j && index !== k && index !== l) {
                let row, col;
                if (groupType === 'row') {
                  row = fixedRow;
                  col = index;
                } else if (groupType === 'column') {
                  row = index;
                  col = fixedCol;
                } else if (groupType === 'box') {
                  row = fixedRow * CHUNK_SIZE + Math.floor(index / CHUNK_SIZE);
                  col = fixedCol * CHUNK_SIZE + (index % CHUNK_SIZE);
                }

                if (puzzle[row][col] === 0) { // 只修改空单元格
                  for (const candidate of quad) {
                    if (candidates[row][col].includes(candidate)) {
                      candidates[row][col] = candidates[row][col].filter((c) => c !== candidate);
                      progress = true;

                      // 如果某个单元格的候选值变为 1，填入该值
                      if (candidates[row][col].length === 1) {
                        const value = candidates[row][col][0];
                        puzzle[row][col] = value;
                        updateCandidates(puzzle, candidates, row, col, value);
                        console.log('filled sudoku with Naked Quads');
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return progress;
}

/**
 * 实现 Hidden Pairs/Triples 策略
 * @param {number[][]} puzzle - 当前的数独谜题（二维数组）
 * @param {number[][][]} candidates - 每个单元格的候选数（二维数组）
 * @returns {boolean} - 如果策略成功应用，返回 true；否则返回 false
 */
function applyHiddenPairs(puzzle, candidates) {
  const SUDOKU_SIZE = 9;
  let progress = false;

  // 对每一行应用 Hidden Pairs
  for (let row = 0; row < SUDOKU_SIZE; row++) {
    const rowCandidates = candidates[row];
    const hiddenPairs = findHiddenPairs(rowCandidates);

    if (hiddenPairs.length > 0) {
      for (const [pair, cells] of hiddenPairs) {
        // 更新候选数
        for (const col of cells) {
          candidates[row][col] = pair.slice(); // 只保留隐藏的配对
        }
        progress = true;
      }
    }
  }

  // 对每一列应用 Hidden Pairs
  for (let col = 0; col < SUDOKU_SIZE; col++) {
    const columnCandidates = candidates.map((row) => row[col]);
    const hiddenPairs = findHiddenPairs(columnCandidates);

    if (hiddenPairs.length > 0) {
      for (const [pair, cells] of hiddenPairs) {
        // 更新候选数
        for (const row of cells) {
          candidates[row][col] = pair.slice(); // 只保留隐藏的配对
        }
        progress = true;
      }
    }
  }

  // 对每一个 3x3 宫应用 Hidden Pairs
  for (let boxRow = 0; boxRow < 3; boxRow++) {
    for (let boxCol = 0; boxCol < 3; boxCol++) {
      const boxCandidates = getBoxCandidates(candidates, boxRow, boxCol);
      const hiddenPairs = findHiddenPairs(boxCandidates);

      if (hiddenPairs.length > 0) {
        for (const [pair, cells] of hiddenPairs) {
          // 更新候选数
          for (const index of cells) {
            const row = boxRow * 3 + Math.floor(index / 3);
            const col = boxCol * 3 + (index % 3);
            candidates[row][col] = pair.slice(); // 只保留隐藏的配对
          }
          progress = true;
        }
      }
    }
  }

  return progress;
}

// 在单个行、列或宫中查找 Hidden Pairs
function findHiddenPairs(candidates) {
  const SUDOKU_SIZE = 9;
  const hiddenPairs = [];

  // 遍历所有可能的配对
  for (let i = 0; i < SUDOKU_SIZE; i++) {
    for (let j = i + 1; j < SUDOKU_SIZE; j++) {
      const pair = [i + 1, j + 1]; // 配对
      const cells = [];

      // 检查这些候选数是否只出现在同一组单元格中
      for (let index = 0; index < candidates.length; index++) {
        const cellCandidates = candidates[index];

        // 检查单元格的候选数是否包含配对中的至少一个数字
        if (pair.some(num => cellCandidates.includes(num))) {
          cells.push(index);
        }
      }

      // 如果配对中的数字只出现在两个单元格中，且这两个单元格的候选数包含配对中的所有数字
      if (cells.length === 2) {
        const [cell1, cell2] = cells;
        const cell1Candidates = candidates[cell1];
        const cell2Candidates = candidates[cell2];

        // 检查这两个单元格的候选数是否都包含配对中的所有数字
        if (pair.every(num => cell1Candidates.includes(num)) &&
            pair.every(num => cell2Candidates.includes(num))) {
          hiddenPairs.push([pair, cells]);
        }
      }
    }
  }

  return hiddenPairs;
}

function applyHiddenTriples(puzzle, candidates) {
  const SUDOKU_SIZE = 9;
  let progress = false;

  // 对每一行应用 Hidden Triples
  for (let row = 0; row < SUDOKU_SIZE; row++) {
    const rowCandidates = candidates[row];
    const hiddenTriples = findHiddenTriples(rowCandidates);

    if (hiddenTriples.length > 0) {
      for (const [triple, cells] of hiddenTriples) {
        // 更新候选数
        for (const col of cells) {
          candidates[row][col] = triple.slice(); // 只保留隐藏的三元组
        }
        progress = true;
      }
    }
  }

  // 对每一列应用 Hidden Triples
  for (let col = 0; col < SUDOKU_SIZE; col++) {
    const columnCandidates = candidates.map((row) => row[col]);
    const hiddenTriples = findHiddenTriples(columnCandidates);

    if (hiddenTriples.length > 0) {
      for (const [triple, cells] of hiddenTriples) {
        // 更新候选数
        for (const row of cells) {
          candidates[row][col] = triple.slice(); // 只保留隐藏的三元组
        }
        progress = true;
      }
    }
  }

  // 对每一个 3x3 宫应用 Hidden Triples
  for (let boxRow = 0; boxRow < 3; boxRow++) {
    for (let boxCol = 0; boxCol < 3; boxCol++) {
      const boxCandidates = getBoxCandidates(candidates, boxRow, boxCol);
      const hiddenTriples = findHiddenTriples(boxCandidates);

      if (hiddenTriples.length > 0) {
        for (const [triple, cells] of hiddenTriples) {
          // 更新候选数
          for (const index of cells) {
            const row = boxRow * 3 + Math.floor(index / 3);
            const col = boxCol * 3 + (index % 3);
            candidates[row][col] = triple.slice(); // 只保留隐藏的三元组
          }
          progress = true;
        }
      }
    }
  }

  return progress;
}
function findHiddenTriples(candidates) {
  const SUDOKU_SIZE = 9;
  const hiddenTriples = [];

  // 遍历所有可能的三元组
  for (let i = 0; i < SUDOKU_SIZE; i++) {
    for (let j = i + 1; j < SUDOKU_SIZE; j++) {
      for (let k = j + 1; k < SUDOKU_SIZE; k++) {
        const triple = [i + 1, j + 1, k + 1]; // 三元组
        const cells = [];

        // 检查这些候选数是否只出现在同一组单元格中
        for (let index = 0; index < candidates.length; index++) {
          const cellCandidates = candidates[index];

          // 检查单元格的候选数是否包含三元组中的至少一个数字
          if (triple.some(num => cellCandidates.includes(num))) {
            cells.push(index);
          }
        }

        // 如果三元组只出现在三个单元格中，且这三个单元格的候选数包含三元组中的所有数字
        if (cells.length === 3) {
          const [cell1, cell2, cell3] = cells;
          const cell1Candidates = candidates[cell1];
          const cell2Candidates = candidates[cell2];
          const cell3Candidates = candidates[cell3];

          // 检查这三个单元格的候选数是否都包含三元组中的所有数字
          if (triple.every(num => cell1Candidates.includes(num)) &&
              triple.every(num => cell2Candidates.includes(num)) &&
              triple.every(num => cell3Candidates.includes(num))) {
            hiddenTriples.push([triple, cells]);
          }
        }
      }
    }
  }

  return hiddenTriples;
}
/**
 * 在行中应用 Hidden Quads 策略
 */
function applyHiddenQuads(puzzle, candidates) {
  const SUDOKU_SIZE = 9;
  let progress = false;

  // 对每一行应用 Hidden Quads
  for (let row = 0; row < SUDOKU_SIZE; row++) {
    const rowCandidates = candidates[row];
    const hiddenQuads = findHiddenQuads(rowCandidates);

    if (hiddenQuads.length > 0) {
      for (const [quad, cells] of hiddenQuads) {
        // 更新候选数
        for (const col of cells) {
          candidates[row][col] = quad.slice(); // 只保留隐藏的四元组
        }
        progress = true;
      }
    }
  }

  // 对每一列应用 Hidden Quads
  for (let col = 0; col < SUDOKU_SIZE; col++) {
    const columnCandidates = candidates.map((row) => row[col]);
    const hiddenQuads = findHiddenQuads(columnCandidates);

    if (hiddenQuads.length > 0) {
      for (const [quad, cells] of hiddenQuads) {
        // 更新候选数
        for (const row of cells) {
          candidates[row][col] = quad.slice(); // 只保留隐藏的四元组
        }
        progress = true;
      }
    }
  }

  // 对每一个 3x3 宫应用 Hidden Quads
  for (let boxRow = 0; boxRow < 3; boxRow++) {
    for (let boxCol = 0; boxCol < 3; boxCol++) {
      const boxCandidates = getBoxCandidates(candidates, boxRow, boxCol);
      const hiddenQuads = findHiddenQuads(boxCandidates);

      if (hiddenQuads.length > 0) {
        for (const [quad, cells] of hiddenQuads) {
          // 更新候选数
          for (const index of cells) {
            const row = boxRow * 3 + Math.floor(index / 3);
            const col = boxCol * 3 + (index % 3);
            candidates[row][col] = quad.slice(); // 只保留隐藏的四元组
          }
          progress = true;
        }
      }
    }
  }

  return progress;
}
function findHiddenQuads(candidates) {
  const SUDOKU_SIZE = 9;
  const hiddenQuads = [];

  // 遍历所有可能的四元组
  for (let i = 0; i < SUDOKU_SIZE; i++) {
    for (let j = i + 1; j < SUDOKU_SIZE; j++) {
      for (let k = j + 1; k < SUDOKU_SIZE; k++) {
        for (let l = k + 1; l < SUDOKU_SIZE; l++) {
          const quad = [i + 1, j + 1, k + 1, l + 1]; // 四元组
          const cells = [];

          // 检查这些候选数是否只出现在同一组单元格中
          for (let index = 0; index < candidates.length; index++) {
            const cellCandidates = candidates[index];

            // 检查单元格的候选数是否包含四元组中的至少一个数字
            if (quad.some(num => cellCandidates.includes(num))) {
              cells.push(index);
            }
          }

          // 如果四元组只出现在四个单元格中，且这四个单元格的候选数包含四元组中的所有数字
          if (cells.length === 4) {
            const [cell1, cell2, cell3, cell4] = cells;
            const cell1Candidates = candidates[cell1];
            const cell2Candidates = candidates[cell2];
            const cell3Candidates = candidates[cell3];
            const cell4Candidates = candidates[cell4];

            // 检查这四个单元格的候选数是否都包含四元组中的所有数字
            if (quad.every(num => cell1Candidates.includes(num)) &&
                quad.every(num => cell2Candidates.includes(num)) &&
                quad.every(num => cell3Candidates.includes(num)) &&
                quad.every(num => cell4Candidates.includes(num))) {
              hiddenQuads.push([quad, cells]);
            }
          }
        }
      }
    }
  }

  return hiddenQuads;
}

// 王舒航&郭集河：初始化候选值列表
function initializeCandidates(sudoku) {
  const candidates = [];
  for (let row = 0; row < ROW_COL_SIZE; row++) {
    const rowCandidates = [];
    for (let col = 0; col < ROW_COL_SIZE; col++) {
      if (sudoku[row][col] === 0) {
        rowCandidates.push(getCandidates(sudoku, row, col));
      } else {
        rowCandidates.push([]); // 已填数字的候选值为空
      }
    }
    candidates.push(rowCandidates);
  }
  return candidates;
}

// 王舒航&郭集河：更新候选值列表
function updateCandidates(puzzle, candidates, row, col, value) {
  candidates[row][col] = []; // 已填数字的候选值为空
 
  
  console.log(`Filling sc (${row}, ${col}) with ${value}`);
  single_candidates.push([row,col,value]);
  // 更新行中的候选值
  for (let c = 0; c < ROW_COL_SIZE; c++) {
    if (c !== col && puzzle[row][c] === 0 ) {
      candidates[row][c] = candidates[row][c].filter(candidate => candidate !== value);
    }
  }

  // 更新列中的候选值
  for (let r = 0; r < ROW_COL_SIZE; r++) {
    if (r !== row && puzzle[r][col] === 0) {
      candidates[r][col] = candidates[r][col].filter(candidate => candidate !== value);
    }
  }

  // 更新宫中的候选值
  const boxRow = Math.floor(row / CHUNK_SIZE) * CHUNK_SIZE;
  const boxCol = Math.floor(col / CHUNK_SIZE) * CHUNK_SIZE;
  for (let r = boxRow; r < boxRow + CHUNK_SIZE; r++) {
    for (let c = boxCol; c < boxCol + CHUNK_SIZE; c++) {
      if ((r !== row || c !== col) && puzzle[r][c] === 0) { // 只更新未填单元格        
        candidates[r][c] = candidates[r][c].filter(candidate => candidate !== value);
      }
    }
  }

  //王舒航&郭集河： 打印候选值表
  console.log(`Updated candidates after filling (${row}, ${col}) with ${value}:`);
  // printCandidates(candidates);
  printSudoku(puzzle);
}

// 王舒航&郭集河：获取候选值
function getCandidates(puzzle, row, col) {
  const used = new Set();

  // 检查行
  for (let c = 0; c < ROW_COL_SIZE; c++) {
    if (puzzle[row][c] !== 0) {
      used.add(puzzle[row][c]);
    }
  }

  // 检查列
  for (let r = 0; r < ROW_COL_SIZE; r++) {
    if (puzzle[r][col] !== 0) {
      used.add(puzzle[r][col]);
    }
  }

  // 检查 3x3 宫
  const boxRowStart = Math.floor(row / CHUNK_SIZE) * CHUNK_SIZE;
  const boxColStart = Math.floor(col / CHUNK_SIZE) * CHUNK_SIZE;
  for (let r = boxRowStart; r < boxRowStart + CHUNK_SIZE; r++) {
    for (let c = boxColStart; c < boxColStart + CHUNK_SIZE; c++) {
      if (puzzle[r][c] !== 0) {
        used.add(puzzle[r][c]);
      }
    }
  }

  // 候选值 = 全部可能值 - 已使用值
  return [...Array(ROW_COL_SIZE).keys()].map((x) => x + 1).filter((x) => !used.has(x));
}


// 获取 3x3 宫的值
function getBox(puzzle, boxRow, boxCol) {
  const box = [];
  for (let i = boxRow * CHUNK_SIZE; i < (boxRow + 1) * CHUNK_SIZE; i++) {
    for (let j = boxCol * CHUNK_SIZE; j < (boxCol + 1) * CHUNK_SIZE; j++) {
      box.push(puzzle[i][j]);
    }
  }
  return box;
}

// 获取 3x3 宫的候选值
function getBoxCandidates(candidates, boxRow, boxCol) {
  const boxCandidates = [];
  for (let i = boxRow * CHUNK_SIZE; i < (boxRow + 1) * CHUNK_SIZE; i++) {
    for (let j = boxCol * CHUNK_SIZE; j < (boxCol + 1) * CHUNK_SIZE; j++) {
      boxCandidates.push(candidates[i][j]);
    }
  }
  return boxCandidates;
}

//王舒航&郭集河： 打印候选值表
function printCandidates(candidates, isRow = false) {
  if (isRow) {
    // 打印单行数据
    let out = '║ ';
    for (let col = 0; col < SUDOKU_SIZE; col++) {
      out += `[${candidates[col].join(',')}] `;
      if (col % BOX_SIZE === 2) {
        out += '│ ';
      }
    }
    out += '║';
    console.log(out);
  } else {
    // 打印整个候选值表
    console.log('Candidate Table:');
    for (let row = 0; row < ROW_COL_SIZE; row++) {
      let rowString = '';
      for (let col = 0; col < ROW_COL_SIZE; col++) {
        rowString += `[${candidates[row][col].join(',')}] `;
      }
      console.log(rowString);
    }
    console.log('---------------------------------');
  }
}
// 王舒航&郭集河：添加自动测试功能
function testSolveSudoku() {
  console.log('Generating Sudoku puzzle...');
  const sudoku = generateSudoku('hard'); // 生成中等难度数独
  // const sudoku = parseSudokuFromInput(input);
  console.log('\nGenerated Sudoku puzzle:');
  printSudoku(sudoku); // 打印生成的数独

  console.log('\nSolving Sudoku...');
  try {
    const solution = solveSudoku(sudoku); // 调用 solveSudoku 方法解决数独
    // console.log('\nSolved Sudoku:');
    // printSudoku(solution); // 打印解决后的数独
  } catch (error) {
    console.error('\nFailed to solve Sudoku:', error.message);
  }
}
// 执行测试
// testSolveSudoku();